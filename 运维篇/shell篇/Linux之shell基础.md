### shell基础

#### shell概述

1.shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容，Bourne家族主要包括sh、Bash、psh、zsh；C家族包括：csh、tcsh

```shell
vi /etc/shells  # 查看支持的shell
```

#### 脚本执行方式

##### echo输出命令

```shell
echo [选项] [输出内容]
选项：
	-e 支持反斜线控制的字符转换
```

#### Bash的基本功能

##### 命令别名和快捷键

```shell
alias 
# 查看所有命令的别名

alias 别名="原命令"
# 设定命令别名

vi ~/.bashrc
# 写入环境变量配置文件

unalias 别名
# 删除别名
```

**命令生效顺序**

- 第一顺位执行用绝对路径或相对路径执行的命令
- 第二顺位执行别名
- 第三顺位执行Bash的内部命令
- 第四顺位执行按照￥PATH环境变量定义的目录查找顺序找到的第一个命令

| 快捷键   | 作用                     |
| -------- | ------------------------ |
| ctrl + c | 强制终止当前命令         |
| ctrl + l | 清屏                     |
| ctrl + a | 光标移动到行首           |
| ctrl + e | 光标移动到行尾           |
| ctrl + u | 从光标所在位置删除到行首 |
| Ctrl + z | 把命令放入后台           |
| Ctrl + r | 在历史命令中搜索         |

##### 历史命令

```shell
history [选项] [历史命令保存文件]
选项：
	-c	清空历史命令
	-w	把缓存中的历史命令写入历史命令保存文件~/.bash_history
# 历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中进行修改
```

##### 输出重定向

```shell
标准输出重定向
	命令 > 文件 # 直接写入，里面有内容就覆盖
	命令 >> 文件 # 追加内容
标准错误输出重定向：
	命令 2> 文件 # 以覆盖的方式把错误信息写入文件
	命令 2>> 文件 # 追加写入到文件
正确输出和错误输出同时保存
	命令 > 文件 2>&1 
	命令 >> 文件 2>&1
	命令 &> 文件
	命令 &>> 文件
	命令 >> 文件1 2>> 文件2

/dev/null # 黑洞
```

##### 输入重定向

```shell
wc [选项] [文件名]
选项：
	-c	统计字节数
	-w	统计单词数
	-l	统计行数
```

##### 多命令顺序执行

| 多命令执行符 | 格式             | 作用                                                      |
| ------------ | ---------------- | --------------------------------------------------------- |
| ：           | 命令1：命令2     | 多个命令顺序执行，命令之间没有任何逻辑联系                |
| &&           | 命令1&&命令2     | 逻辑与 当命令1正确执行，命令2才会执行，否则就不会执行     |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或 命令1执行不正确，2才会执行，命令1正确，2就不会执行 |

```shell
管道符
命令格式：
	命令1 | 命令2
	# 命令1的正确输出作为命令2的操作对象
netstat -an
# 查看端口连接和用户连接
```

##### 通配符

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ？     | 匹配一个任意字符                                             |
| *      | 匹配0个或多个任意字符                                        |
| []     | 匹配括号中任意一个字符                                       |
| [-]    | 匹配括号中任意一个字符如：[a-z]                              |
| [^]    | l逻辑非，表示匹配不是括号中的任意字符 [ ^0-9],表示不匹配数字 |

##### Bash中其他特殊符号

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ' '  | 单引号，在单引号中所有特殊符号，如“$ `（反引号） ”都没有特殊含义 |
| " "  | 双引号，在单引号中所有特殊符号，都没有特殊含义，但“$ `（反引号） 和 \ 是一个例外”都没有特殊含义 |
| ``   | 反引号，反引号括起来的是命令系统，在bash中会先执行它，和$()作用一样，不过推荐使用 \$ (),因为反引号容易看错 |
| $()  | 和反引号的作用一样                                           |
| #    | \# 号代表注释                                                |
| $    | 用于调用变量值，如$PATH                                      |
| \    | 转意符，跟在\后面的符号将失去特殊含义                        |

### Bash变量

#### 什么是变量与变量的分类

##### 什么是变量

- 变量是计算机内存的单元，其中存放的值可以改变
- 变量让你能够把程序中准备使用的每一段数据都赋给一个简短、易于记忆的名字

##### 变量命名规则

- 变量名必须以字母或下划线开头，名字中间只能由字母、数字和下滑线组成
- 变量长度不得超过255个字符
- 变量名在有效范围之内必须唯一
- 在Bash中，变量的默认类型必须是字符串类型

##### 变量的分类

- 用户自定义变量
- 环境变量
- 位置参数变量
- 预定义变量

#### 用户自定义变量

##### 定义变量

```shell
变量名=变量值
例如：
	x=5
	name="xxx"
```

##### 变量调用

```shell
echo $变量名
例如：
	echo $x
	echo $name
```

##### 变量叠加

```shell
x=123
x="$x"456
x=${x}789
```

##### 变量查看

```shell
set
选项：
	-u	如果设定此选项，调用未声明变量时会报错（默认无任何提示）
```

##### 变量删除

```shell
unset 变量名
```

#### 环境变量

##### 环境变量与用户自定义变量的区别

- 环境变量是全局变量
- 用户自定义变量是局部变量

##### 设置环境变量

```shell
export 变量名=变量值
或
变量名=变量值
export 变量名

```

##### 查看环境变量

```shell
set 
# 查看所有变量

env
# 查看环境变量
```

##### 删除变量

```shell
unset 变量名
```

##### 常用环境变量

```shell
HOSTNAME	主机名
SHELL		当前的shell
TERM		终端环境
HISTSIZE	历史命令条数
SSH_CLIENT	当前操作环境是用ssh连接的，这里记录客户端ip
SSH_TTY		ssh连接的终端pts/1
USER		当前登录用户
```

PATH环境变量

```shell
PATH变量	系统查找命令的路径

echo $PATH
# 查看PATH环境变量

PATH="$PATH":/root/sh
# 增加PATH变量值
```

##### PS1环境变量

```shell
PS1变量	命令提示符设置
以自行调整全局变量/etc/profile文件用于永久生效 PS1='[\u@\h \W\t]\$'
\d　　日期
\H　　完整主机名
\h　　主机名第一个名字
\t　　时间24小时制HHMMSS
\T　　时间12小时制
\A　　时间24小时制HHMM
\u　　当前用户账号名
\v　　BASH的版本
\w　　完整工作目录
\W　　利用basename取得工作目录名
\#　　下达的第几个命令
\$　　提示字符，root为"#"，普通用户为"$"

PS1显示ip地址
export PS1="[\u@\h `/sbin/ifconfig ens33 | sed -nr 's/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'` \w]\$"
```

##### 当前语系查询

```shell
locale
# 查询当前系统语系
	LANG	定义系统主语系的变量
	LC_ALL	定义整体语系的变量
	
echo $LANG
# 查看系统当前语系

locale -a	| more
# 查看linux支持的所有语系
```

##### 查询系统默认语系

```shell
cat /etc/sysconfig/i18n
# centos 6
```

##### Linux中文支持

前提条件，正确安装的中文字体和中文语系

- 如果有图形界面，可以正确支持中文显示
- 如果使用第三方远程工具，只要语系设定正确，可以支持中文显示
- 如果使用纯字符界面，必须使用第三方插件（如zhcon等）

#### 位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令背书，$1-$9代表第一到第九个参数，十以上的需要用大括号包括，如${10} |
| $*           | 这个变量代表命令行中所有参数，$*把所有的参数都看做一个整体   |
| $@           | 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中所有参数的个数                           |

```shell
例子1：
    #!/bin/bash
    nun1=$1
    num2=$2
    sum=$(($num1+$num2))
    # 变量sum是num1和num2的和
    echo $sum
    # 打印变量sum的值
    
例子2：
	#!/bin/bash
	echo "这是$*"
	echo "这是$@"
	echo "这是$#"
	
例子3:
	$* 	是指一个整体，只能循环一次
	$@	类似于一个列表，可以循环一个个的取出

```

#### 预定变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果值非0（具体哪个数，由命令自己决定），则证明上一个命令执行不正确 |
| $$         | 当前进程的进程号（PID）                                      |
| $!         | 后台运行的最后一个进程的进程号（PID）                        |

##### 接收键盘输入

```shell
read [选项] [变量名]
选项：
	-p	提示信息，等待read输入时，输出提示信息
	-t	描述，read命令会一直等待用户输入，使用此选项可以指定等待时间
	-n	字符数，read命令只接受指定字符数，就会执行
	-s	隐藏输入数据，适用于机密信息输入
例子：
	#!/bin/bash
	
	read -p "请输入用户名：" name
	echo $name 
```

### 运算符

#### declare命令

```shell
declare 声明变量类型
declare [+/-] [选项] 变量名
选项：
	-	给变量设定类型属性
	+	取消变量的类型属性
	-a	声明变量类型为数组
	-i	将变量声明为整数型
	-x	将变量声明为环境变量
	-r	将变量声明为只读类型
	-p	显示指定变量的被声明的类型

例子：
	aa=1
	bb=2
	declare -i cc=$aa+$bb
	# 声明变量cc的类型是整数型，他的值是aa和bb的和
```

##### 声明数组变量

```shell
# 定义数组
movie[0]=zp
movie[1]=tp
declare -a movie[2]=live

# 查看数组
echo ${movie}
echo ${movie[2]}
echo ${movie[*]}
```

##### 声明环境变量

```shell
declare -x test=123
# 和export作用相似，但其实是declare命令的作用
```

##### 声明变量只读属性

```shell
declare -r test
# 给test赋予只读属性，但是注意只读属性会让变量不能修改和删除，甚至不能取消只读属性
```

##### 查询变量的属性

```shell
declare -p
# 查询所有变量的属性
declare -p 变量名
# 查询指定变量的属性
```

#### 数值运算的方法

```shell
expr和let数值运算工具

dd=$(expr $aa + $bb)
# dd的值是aa和bb的和，注意+号两边必须加空格
```

##### \$ ((运算式))或 $[运算式]

```shell
ff = $(($aa+$bb))
gg=$[$aa+$bb]
```

##### 运算符

| 优先级 | 运算符                             | 说明                               |
| ------ | ---------------------------------- | ---------------------------------- |
| 13     | -,+                                | 单目负，单目正                     |
| 12     | !,~                                | 逻辑非，按位取反或补码             |
| 11     | * / %                              | 乘，除、取模                       |
| 10     | +,-                                | 加、减                             |
| 9      | <<,  >>                            | 按位左移，按位右移                 |
| 8      | < = ,>= ,< ,>                      | 小于或等于，大于或等于，大于，小于 |
| 7      | == ,!=                             | 等于，不等于                       |
| 6      | &                                  | 按位与                             |
| 5      | ^                                  | 按位异或                           |
| 4      | \|                                 | 按位或                             |
| 3      | &&                                 | 逻辑与                             |
| 2      | \|\|                               | 逻辑或                             |
| 1      | =,+=,-=,*=,/=,%=,&=,^=,\|=,<<=,>>= | 赋值，运算且赋值                   |

#### 变量测试



### 环境变量

#### 配置文件简介

PATH,HISTSIZE,PS1,HOSTNAME等环境变量写入对应的环境变量配置文件

环境变量配置文件中主要是定义系统操作环境生效的系统默认环境变量，如PATH等

- /etc/profile
- /etc/profile.d/*.sh
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

##### source命令

```shell
source 配置文件
或
. 配置文件
# 修改文件之后，必须注销重新登录才能登录也可以source一下
```

#### 配置文件的功能

##### /etc/profile的作用

- USER变量
- LOGNAME变量
- MAIL变量
- HOSTNAME变量
- HISTSIZE变量
- umask变量
- 调用/etc/profile.d/*.sh文件

#### 其他配置文件

##### 注销时生效的环境变量配置文件

- ~/.bash_logout

##### 其他配置文件

- ~./bash_history

##### shell登录信息

- 本地终端登录信息 ： /etc/issue

| 转义符 | 作用                            |
| ------ | ------------------------------- |
| \d     | 显示当前系统日期                |
| \s     | 显示操作系统名称                |
| \l     | 显示登录终端号，这个比较常用    |
| \m     | 先试试硬件体系结构如i386 i686等 |
| \n     | 显示主机名                      |
| \o     | 显示域名                        |
| \r     | 显示内核版本                    |
| \t     | 显示当前系统时间                |
| \u     | 显示当前登录用户的序列号        |

##### 远程终端欢迎信息

```shell
/etc/issue.net
转义符在/etc/issue.net文件中不能使用
是否显示欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入"Banner/etc/issue.net" 行才能显示（记得重启ssh服务）
```

##### 登录后欢迎信息：/etc/motd

- 不管是本地登录，还是远程登录，都可以显示欢迎信息

### 正则表达式之字符截取命令

#### cut字段提取命令

```shell
cut [选项] 文件名
选项：
	-f	列号：提取第几列
	-d	分隔符：按照指定分隔符分隔
例子：
	cut -d ":" -f 1,3 /etc/passwd
	# 截取以：分隔的第一列和第三列
```

#### printf命令

- printf  '输出类型输出格式' 输出内容
- 输出类型
	- %ns：输出字符串，n是数字代指输出几个字符
	- %ni：输出整数，n是数字代指输出几个数字
	- %m.nf :输出浮点数，m和n是数字，代指输出的整数位和小数位，如%8.2f代表共输出8位数，其中2位是小数，6位是整数
- 输出格式
	- \a:输出警告声音
	- \b:输出退格键，也就是backspace键
	- \f：清除屏幕
	- \n:换行
	- \r:回车
	- \t:水平输出退格符
	- \v:垂直输出退格符

#### awk命令

```shell
awk '条件1{动作1}条件2{动作2}..' 文件名
条件（pattern）
	一般使用关系表达式作为条件
	x > 10 判断变量x是否大于10
	x >= 10 判断变量x是否大于等于10
	x <= 10 判断变量x是否小于等于10
动作（action）
	格式化输出
	流程控制语句
	
例子1：
	df -h | awk '{print $5 }'

BEGIN	在开始执行的东西
END		在结束执行的命令
例子2：
	df -h | awk'END{print "end"}{print $5}'

FS内置变量
例子：
	awk 'BEGIN{FS=":"}{print $1}'
	
关系运算符
    例子：awk '$4 >= 70{print $2}'
```

#### sed命令

```shell
sed [选项] '[动作]' 文件名
选项：
	-n	一般sed命令会把所有数据都输出到屏幕，如果加入此选择则只会经过sed命令处理的行输出到屏幕
	-e	允许对输入数据应用多条sed命令编辑
	-i	用sed的修改结果直接修改数据的文件，而不是屏幕输出
动作：
	-a	追加，在当前行后添加一行或多行
	-c	行替换，用c后面的字符串替换原有数据行
	-i+	插入，在当期行前插入一行或多行
	-d	删除，删除指定的行
	-p	打印，输出指定行
	-s	字符串替换，用一个字符串替换另一个字符串，格式为"行范围s/旧字符串/新字符串/g"类似于vim的替换

例子：
	sed '2，d' student.txt
	# 删除第二行到第四行
	sed '2a nnnnn' student.txt
	# 在第二行后面加入 nnnnn
	sed '2i nnnnn' student.txt
	# 在第二行插入 nnnnn
	sed '4c dasdasda' student.txt
	# 把文件第四行替换为dasdasda

字符串替换
sed 's/旧的/新的/g'

sed '3s/60/90/g' student.txt
# 把第三行数据的60替换为90

sed -e 's/xx//g;s/oo//g' student.txt
# -e执行多条，用；分隔
```

### 字符处理命令

#### sort命令

```shell
sort [选项] 文件名
选项：
	-f	忽略大小写
	-n	以数值型进行排序，默认使用字符串进行排序
	-r	反向排序
	-t	指定分隔符
	-k n[,m] 按照指定的字段排序，从第n个字段开始，m字段结束（默认行尾）
例子：
	sort -n -t ":" -k 3,3 /etc/passwd
	# 指定分隔符是：，用第三段开头，第三段结尾排序，就是只用第三段进行排序
```

#### 统计命令wc命令

```shell
wc [选项] 文件名
选项：
	-l	只统计行数
	-w	只统计单词数
	-m	只统计字符数
```

### 条件判断

#### 条件判断式

##### 按照文件类型进行判断

| 测试选项 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| -b 文件  | 判断该文件是否存在，并且是否为块设备文件（是块设备文件为真） |
| -c 文件  | 判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真） |
| -d 文件  | 判断该文件是否存在，并且是否为目录文件（是目录文件为真）     |
| -e 文件  | 判断该文件是否存在（存在为真）                               |
| -f 文件  | 判断该文件是否存在，并且是否为普通文件（是普通文件为真）     |
| -L 文件  | 判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真） |
| -p 文件  | 判断该文件是否存在，并且是否为管道文件（是管道文件为真）     |
| -s 文件  | 判断该文件是否存在，并且是否为非空（非空为真）               |
| -S 文件  | 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真） |

```shell
两种判断格式
test -e /root/1.log
[-e /root/1.log]  # 推荐

[-d /root] && echo "yes" || echo "no"
# 第一条为真则为yes，否则为no
```

##### 按照文件权限来判断

| 测试选项 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| -r 文件  | 判断该文件是否存在，并且拥有该文件的读权限（有读权限为真）   |
| -w 文件  | 判断该文件是否存在，并且拥有该文件的写权限（有写权限为真）   |
| -x 文件  | 判断该文件是否存在，并且拥有该文件的执行权限（有执行权限为真） |
| -u 文件  | 判断该文件是否存在，并且拥有该文件的SUID权限（有SUID权限为真） |
| -u 文件  | 判断该文件是否存在，并且拥有该文件的SGID权限（有SGID权限为真） |
| -k 文件  | 判断该文件是否存在，并且拥有该文件的SBit权限（有SBit权限为真） |

##### 两个文件之间进行比较

| 测试选项         | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| 文件1 -nt 文件 2 | 判断文件1的修改时间是否比文件2新（如果新则为真）             |
| 文件1 -ot 文件2  | 判断文件1的修改时间是否比文件2旧（如果旧则为真）             |
| 文件1 -ef 文件2  | 判断文件1是否和文件2的inode号一致，可以理解问是否是同一文件，这个是判断硬链接的一种方式 |

##### 两个整数之间比较

| 测试选项        | 作用                                       |
| --------------- | ------------------------------------------ |
| 整数1 -eq 整数2 | 判断整数1是否和整数2相等（相等为真）       |
| 整数1 -ne 整数2 | 判断整数1是否和整数2不相等（不相等为真）   |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2（大于为真）         |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2（小于为真）         |
| 整数1 -ge整数2  | 判断整数1是否大于等于整数2（大于等于为真） |
| 整数1 -le整数2  | 判断整数1是否小于等于整数2（小于等于为真） |

##### 字符串的判断

| 测试选项            | 作用                                           |
| ------------------- | ---------------------------------------------- |
| -z 字符串           | 判断字符串是否为空（为空返回真）               |
| -n 字符串           | 判断字符串是否为非空（非空返回真）             |
| 字符串1 == 字符串2  | 判断字符串1是否和字符串2相等（相等返回真）     |
| 字符串1 ！= 字符串2 | 判断字符串1是否和字符串2不相等（不相等返回真） |

##### 多重条件判断

| 测试选项       | 作用   |
| -------------- | ------ |
| 判断1 -a 判断2 | 逻辑与 |
| 判断1 -o 判断2 | 逻辑或 |
| ！ 判断        | 逻辑非 |

#### if语句

```shell
单分支if语句格式：
if [条件判断式]；then
	程序
fi
或者
if [条件判断式]
	then
	程序
fi

双分支if语句
if [条件判断式]
	then
	条件成立
	else
	条件不成立
fi 
www.netcraft.com

多分支if语句
if [条件判断1]
	then
	条件1成立
	elif [条件2]
	then
	条件2成立执行的
	else
	都不成立要执行的
fi
```

#### case语句

```shell
case $变量名 in "值1"）
	如果变量的值等于值1，则执行程序1
	；；
	"值2"）
	如果变量的值等于值2，则执行程序1
	*）
	如果都不等于，执行它
	；；
esac
```

#### for循环

```shell
语法1
for 变量 in 值1 值2 值3
	do
		程序
	done

```

#### while循环和until循环

```shell
while [条件]
	do
		循环体
	done
```