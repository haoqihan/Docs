### 深入理解python库

#### 库、模块和包

```shell
库 library：一种对特定功能集合的通俗说法
- 包含一些程序功能，通过import 引入使用，对应模块和包
- 标准库：Standard Library，与python解释器一同安装的库
- 第三方库：Third-Party Library ，需要额外安装的库

模块 Module：以单个文件为命名空间的代码片段
- 模块是一个单独的py文件、模块名就是文件名
- 模块的本质是一个独立的，由模块名组织的命名空间
- 模块中可以引入其他模块，并由一些Python语法来约束和管理

包 Package：由一组模块构成、由层次命名空间的程序功能
- 包由多个模块（多个.py文件）有组织的构成
- 木块的组织方式构成了命名空间的层次结构
- 包是模块的上一级组织概念，其中可以包括子包

模块是一切库的基础单元
- 包由模块构成，可以理解为：包是目录，模块是py文件
- 库是通俗说法，具体指python的模块和包
- Python库的核心是模块及模块的组织方式（体现为命名空间）
```

#### 模块的命名空间

```shell
模块是命名空间
- 模块对应的.py文件，它是一个独立的命名空间
- 模块内可能包含：类、函数、语句(直接执行)、变量等元素
- 模块内还包括一些其他模块进行约束和管理的语法元素

- 模块中语句: 在import时一次性执行
- 模块内变量、类和函数：在import时采用<模块>方式可访问
- 单下划线的顶层命名元素：不会from .. import * 时导入
```

#### 包的命名空间

```python
包 package ：由一组模块构成、有层次命名空间的程序功能
- 每个包需要包含一个__init__.py 文件表达包的组织
- __init__.py 可以是空文件，即文件存在即可
- 每个包可以嵌套包含更多子包

包是一个有层次的命名空间
- 通过包的组织可以形成由英文句号(.)分隔的层次化命名空间
- __init__.py 用来构成包的定义,区别包含py文件的普通目录
- 包、子包和模块可以通过import进行导入或单独导入
```

#### 模块的名称属性

```shell
名称属性:表达模块名称的预定义变量
__name__	模块或包的名字,例: m.__name__

- 当程序以脚本方式直接执行时,__name__ 的值是 __main__
- 当程序以模块方式被直接引用时,__name__的值为模块的名称
- 作用：区别程序以何种方式执行
```

### 模块和包的构建

#### 模块的构建

```shell
模块构建原则：如何编写好一个py文件
- 功能闭包：单个py文件实现单个且完整的功能
- 抽象适度：用函数或类进行抽象，结合功能选择合适抽象
- 操作闭包：模块无顶层可执行语句，导入时无输出

- 功能闭包：功能定义要清晰，设计要合理（松耦合vs紧耦合）
- 抽象适度： 采用类或函数，尽量使用一种：多种也无妨
- 操作闭包：采用__name__、无全局可执行语句、尽量无全局变量
```

#### 常规包的构建

```shell
包由两种：常规包和命名空间包
- 常规包：Regular Packages，通过__init__.py对文件和目录组织形成包
- 命名空间包：Namespace packages，由更分散子包组成的包
- 子包的位置可以在文件系统中不连续
- 子包可以是压缩文件或网络连接或其他系统资源

常规包：Regular Packages
- 连续目录空间表达的，有层次的命名空间
- 每个目录中包含一个__init__.py文件，可以是空文件
- 当包、模块被导入时，对应目录的__init__.py文件将被执行

每个包仅被导入一次，且白导入按照层次结构进行的

__all__属性
- from .. import * 的形式需要在__init__.py文件中增加__all__属性赋值
- __all__需要被赋值为列表对象，包含当前包下所有希望被导入的模块名称
- __all__用来辅助导入模块的，不能辅助导入列表

常规包的构建流程
- 设计好层次结构(命名空间),每个目录配置一个__init__.py文件
- 完善__init__.py 文件，并酌情赋值__all__属性
- 再次理解包和模块的不同，模块是提供功能，包是提供命名空间

常规包的导入流程
- 每个包仅被导入一次，且包带入按照层次结构进行
- 直接导入包不能调用功能，需要导入到模块层次
- from .. import 直接带入具体模块，可以简化调用时命名空间表达
- __init__.py 文件中通过__all__属性支持from .. import * 的功能
```

#### 命名空间包的构建

```shell
命名空间包：表达命名空间层次结构的一种逻辑包形式
- 命名空间中各部分可以在不同的文件系统位置
- 命名空间中各子包不包含__init__.py文件(普通目录)
- Python解释器通过sys.path 变量来`隐式`维护命名空间包

sys.path ：指定搜索路径的字符串列表
- 指定import时搜索模块或包的路径列表，路径是相对或绝对路径
- sys.path是一个列表类型，可以用sys.path.append(p) 增加路径p
- 载入后，根据其中包的名称和层次自然组合成了命名空间包

__path__属性
- 记录了某个包(命名空间)的绝对路径，列表类型
- 常规包：路径单一，列表中只有一个元素
- 命名空间包:路径是多元的，列表中可能由多个元素
```

```python
# 一个简单的命名空间包
import sys
sys.path += ["project1","project2"]
import pkg1.m1
import pkg1.m3

print(pkg1.__path__)
```

### 深入理解import系统

#### import系统

```shell
import系统：扩展命名空间及功能的方法
- 构成：import 保留字、__import__()函数和importlib标准库
- 步骤：模块的查找、模块的加载
- 价值：import系统是python代码复用和命名空间管理的精髓

- import保留字：调用__import__()进行模块查找，以及模块加载
- __import__()函数：模块的查找，建立模块对象
- importlib标准库：与import系统相关的丰富api

万物皆对象：模块导入之后成为了对象
- 模块的对象形式：模块在程序中使用都是以对象形式体现
- 类似类对象，模块对象只有一个
- 模块对象生成时，模块中代码会被执行，因此会有类对象产生
```

#### 模块的查找

```shell
查找的开始
- 输入参数：模块的名字 例如：pkg.pkg1.m1
- 输入方式：import保留字，__import__()、importlib标准库
- 基本行为：按层次结构逐层查找：例如pkg->pkg1->m1

查找路径：1.sys.modules
- 第一步查找sys.modules，之前被引入模块的缓存(cache)
- sys.modules是一个字典，<模块名/对象引用>：加载路径
- 如果模块不在sys.modules中，则进入下一步

查找路径:2.查找策略
- 用户通过import钩子扩展的查找方式
- 内置模块的路径
- sys.path(列表变量)提供的加载路径，可以是zip文件或url文件

import钩子：import hook
- 扩展查找模块的方式：meta_path 方式和import路径方式
- meta_path:将查找方法增加到sys.meta_path 列表变量
- import路径：将查找方法注册到sys.path_hooks列表变量
```

#### 模块的加载

```shell
建立模块对象的过程
- 1.找到模块后，如果模块对象存在，则使用现有模块对象
- 2.创建一个新的模块对象，将其加入sys.modules 
- 3.在程序当前命名空间执行模块代码

创建对象：importlib.abc.Loader.create_module()
执行对象:importlib.abc.Loader.exec_module()

模块对象的命名空间
- 模块的命名空间与引用位有直接关系
- 如果引用在文件顶层，则使用文件顶层命名空间访问
- 如果引用在非顶层，则使用局部命名空间访问模块
```

#### import的使用方式

```python
import的三种使用方式
- import <模块名>
- from <模块名> import <类、函数名、*>
- import <模块名> as <别名>

import <模块名>
- 当前命名空间下的一个子命名空间
- 成功加载后，产生一个与<模块名>同名的<模块对象名>
- 实际上：<模块对象名>.<子命名空间内元素>方式访问

from <模块名> import <类、函数名、*>
- 将导入元素加载到当前命名空间下
- 成功加载后，产生类对象或函数对象，覆盖同名对象
- 实际上：<类对象名> 或<函数对象名>方式访问

import <模块名> as <别名>
- 当前命名空间下的一个子命名空间
- 成功加载后产生一个与<别名>同名的<模块对象名>
- 实际上：<模块别名>.<子命名空间内元素>方式访问
```

### python第三方库的发布

### 发布前的准备

```shell
Python第三方库发布
- Pypi :Python Package index ，用来登记第三方库的信息
- Github、bitbucket：存储第三方库源码及文档
- 目的：通过pip 进行安装和管理、源码和文档网络可管理

一些基本概念
- 项目 project：Pypi上一组发布和文件的统称
- 发布 release :项目的一个特定版本，每个发布有一个确定的版本号
- 文件file,即package ,一次发布包含的具体文件

更新工具
 更新 setuptools 、wheel、twine工具
 python -m pip install --user --upgrade setuptools wheel twine
```

#### 发布流程

```shell
第一步：整理目录结构
第二步：创建其他相关文件
- setup.py ：配置发布信息的文件，很重要
- README.md ：markdown格式的说明文件
- LICENSE:版权声明文件

第三步：执行打包命令
python setup.py sdist bdist_wheel
				源发布	可执行发布
第四步：执行发布命令
twine upload dist/*
```

#### 发布概念

```shell
与发布 Distribution 相关的概念
打包发布： built Distribution,对文件整理打包后进行发布
源发布：Source Distribution，发布源代码的方式，简称sdist
可执行发布：Binary Distribution，发布编译后可执行代码方式

打包发布：一次发布一个打包文件，比如：.tar.gz 或wheel文件
源发布：对于纯python编写的库，源发布有最佳的适用性
可执行发布：对于各类多语言的扩展库，节省了本机编译需求，适用性较好

与打包格式相关的概念
- Egg：一种打包格式，已经被wheel替换
- Wheel：一种打包合适，python主流打包方式，PEP427
- Egg和Wheel都是打包格式，可以包括源代码或可执行代码
```

