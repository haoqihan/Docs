pip的使用

```shell
# 安装
pip install jieba   或 pip install jieba-0.39.zip

# 更新
pip install -U jieba

# 卸载
pip uninstall jieba

# 只下载，不安装
pip download jieba

# 查看第三方库详情
pip show jieba

# 根据关键词在名称和介绍中搜索第三方库
pip search blockchain

# 列出当前系统安装的第三方库
pip list

# 指定当前用户
pip install  --user jieba
```

uci 安装

```shell
网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/

uci安装的三个步骤
    步骤一、在UCI页面搜索对应的第三方库
    步骤二、下载对应python解释器的编译后的版本
    步骤三、本地安装pip install <下载文件名>
```

pip安装脚本



第三方解析库

```shell
1.pyinstaller 
2.jieba
3.wordcloud
```

pyinstaller库的使用

```shell
pyinstaller 将py文件源代码转换为可执行文件的功能
```

使用

```shell
pyinstaller -F <文件名.py>
pyinstaller [options] script [script..]
```

命令说明

| 选项                 | 选项说明                                   |
| -------------------- | ------------------------------------------ |
| -h 或--help          | 显示帮助信息                               |
| -v 或--version       | 显示版本信息                               |
| --dispath dir        | 制定输出目录，默认是./dist                 |
| --workpath wdir      | 指定临时存储文件的目录，默认是./build      |
| -y 或--noconfirm     | 强制替换输出目录内容，没有确认询问         |
| -D 或--onedir        | 创建一个目录，包含可执行程序和程序依赖文件 |
| -F 或onefile         | 创建一个独立的可执行文件                   |
| -n NAME 或-name NAME | 指定输出文件的名称目录                     |
| -i  <图标文件名.ico> | 指定打包程序使用的图标（ico） 文件         |

jieba库的使用

介绍

```shell
中文文本需要通过分词获得单个词语的信息
jieba库提供三种分词模式，支持自定义词典
```

```shel
# 三种分词模式
- 精确模式：将文本精确切开，分词无冗余，适合文本分词
- 全模式：把文本中所有可能成词的词语扫描出来，速度快，不能解决歧义
- 搜索引擎模式：在精确模式基础上，对长词再次切分，提高召回率
```

| 函数                            | 描述                                                       |
| ------------------------------- | ---------------------------------------------------------- |
| jieba.cut(s)                    | 精确模式，分词后返回一个迭代器，用for..in 形式便利结果     |
| jieba.lcut(s)                   | 精确模式，分词后返回一个列表                               |
| jieba.cut(s，cut_all=True)      | 全模式，分词返回一个迭代器，用for..in 形式便利结果         |
| jieba.cut(s，cut_all=True)      | 全模式，分词后返回一个列表                                 |
| jieba.cut_for_search("新时代")  | 搜索引擎模式，分词后返回一个迭代器，用for..in 形式便利结果 |
| jieba.lcut_for_search("新时代") | 搜索引擎模式，分词后返回一个列表                           |
| jieba.add_word(w)               | 向分词词典增加新词w                                        |

### wordcloud库的使用

介绍

```shell
wordcloud.WordCloud() 代表一个文本对应的词云
可以根据文本中词语出现的频率等参数绘制词云
绘制词云的形状、尺寸和颜色等可以设定
```

常用用法

```python
w = wordcloud.WordCloud() 
以WordCloud对象为基础
配置参数、加载文本、输出文件
```

方法

| 方法                | 描述                             |
| ------------------- | -------------------------------- |
| w.generate(txt)     | 向WordCloud对象w中加载文本txt    |
| w.to_file(filename) | 将词云输出为图像文件，.png或.jpg |
|                     |                                  |

WordCloud参数

| 参数             | 描述                                                       |
| ---------------- | ---------------------------------------------------------- |
| width            | 指定词云对象生成图片的宽度，默认为400像素                  |
| height           | 指定词云对象生成图片的高度，默认为200像素                  |
| min_font_size    | 指定词云中最小字号，默认为4号                              |
| max_font_size    | 指定词云中字体的最大字号，根据高度自动调节                 |
| font_step        | 指定词云中字体字号的步进间隔，默认为1                      |
| font_path        | 指定字体文件的路径，默认为None  例子：font_path=“msyh.ttc” |
| mask             | 指定词云形状，需要引用 imread() 函数，默认为长方形         |
| background_color | 指定词云的背景颜色                                         |
|                  |                                                            |

例子：

```python
import wordcloud
w = wordcloud.WordCloud()  # 步骤一、配置对象参数
w.generate("one python")   # 步骤二、加载词云文本
w.to_file("zz.png")       # 步骤三、输出词云文件
```



### pipenv的使用

介绍

```shell
pipenv库提供基于项目的虚拟环境维护及python库管理功能
- 以项目为单位隔离python环境，进而使用不同的python库版本
- 自动管理安装python库及其他依赖库
- 命令行工具：基于virtualenv和pip，目前最好用的虚拟环境维护工具
```

原理

```shell
pipenv 库使用pipfile 和Pipfile.lock 来管理虚拟环境
- Pipfile：记录虚拟环境信息，尤其是python库
- pipfile.lock 锁定python库版本
- 两个文件共同表达了虚拟环境
```

基本使用

```shell
pipenv --three  或 pipenv --python 3.6 # 建立python3.6的环境
pipenv shell # 进入虚拟环境命令行
pipenv install  jieba   # 安装第三方库
pipenv graph  # 展示虚拟环境中的库依赖
pipenv run  xx.py  # 使用虚拟环境执行文件
exit # 退出虚拟环境
```

### tabulate库的使用

介绍

```shel
tabulate 库提供优雅打印表格数据的功能
- 支持二位列表、二维迭代类型、字典迭代等类型
- 支持Numpy二维数组、pandas.DataFrame 类型
- 输出表格可以通过参数自定义风格
```

基本使用

```python
from tabulate import tabulate
tabulate(table,headers,tablefmt,numalign)
	- table:表格数据或变量
	- headers 定义表格的表头
    - tablefmt 定义表格风格
    - numalign 设置全表格数字的对其方式，默认智能对其
plain 	rest 		simple 		mediawiki
grid  	moinmoin 	fancy_grid	youtrack
pipe	html		orgtbl		latex
jira	latex_raw	presto		latex_booktabs	
psql	textile
```

### QRcode库的使用

介绍

```shell
QRcode库提供二维码生成功能
- 支持各种类数据的二维码生成
img = make(txt,border=4)
- txt:待转变为二维码的字符或字符串
- border：设置二维码边的宽度
- img：一个PIL库类型的图像句柄
```

实例

```shell
>>> import qrcode
>>> img = qrcode.make("http://www.baidu.com")
>>> img.save("百度二维码.png"）
```

## 面对对象

### 编程模式

```shell
python语言的“万物皆对象”
- python语言中所有的数据类型都是对象，函数是对象，模块是对象
- python所有的类都继承于基础类object
- python语言中数据类型的操作功能都是类方法的体现

OOP：object-Oriented Programming
- OOP：面对对象编程，一种编程思想，重点在于高抽象的复用代码
- OOP把对象当做程序的基本单元，对象包含数据和操作数据的函数
- OOP的本质是把问题抽象为以对象为中心的计算机程序
- OOP在较大规模或复杂项目中十分有用，OOP可以提高协作产量
- OOP主要价值在于代码的复用
- OOP只是一种编程模式，非解决问题的高级方法

面向过程 VS 面向对象
- 面向过程：以解决问题的过程步骤为核心编写程序的方式
- 面向对象：以对象构建和应用为核心的编写程序的方式
- 所有OOP能解决的事情，面向过程也能解决

面向对象的三大特征
- 封装：属性和方法的抽象，用数据和操作数据的方法来形成对象逻辑
- 继承：代码复用的高级抽象，用对象之间的继承关系来形成代码复用
- 多态：方法灵活性的抽象，让对象的操作更加灵活，更多复用代码

封装 Encapsulate ：属性和方法的抽象
- 属性的抽象：对类的属性(变量)进行定义，隔离及保护
- 方法的抽象：对类的方法(函数)进行定义、隔离及保护
- 目标是形成一个类对外可操作属性和方法的接口

继承 inheritance ：代码复用的高级抽象
- 继承是面对对象设计的精髓之一
- 实现以类为单位的高抽象级别代码复用
- 继承是新定义的类能够几乎完全使用原有类属性和方法的过程

多态 Polymorphism ：针对方法、方法灵活性的抽象
- 参数类型的多态：一个方法能够处理多个类型的能力
- 参数形式的多态：一个方法能够处理多个参数的能力
- 多态是OOP的一个传统概念，Python天然支持多态，不需要特殊语法
```

常用术语

```shell
类Class 和 对象 Object
- 类：逻辑抽象和产生对象的模板，一组变量和函数的特定编排
- 对象：具体表达数据及操作的实体，相当于程序中的“变量”
- 实例化：从类到对象的过程，所有“对象”都源于某个“类”

面对对象术语概念
- 对象：类对象、实例对象
- 属性：存储数据的”变量“，包括：类属性、实例属性
- 方法：操作数据的“函数”
	包括：类方法、实例方法、自由方法、静态方法、保留方法

类对象 VS 实例对象
- 类对象：class Object ，维护每个python类基本信息的数据结构
- 实例对象：instance Object，python类实例后产生的对象，简称“对象”
- 这是一组概念，类对象全局只有一个，实例对象可以生成多个

- 三个特性：封装继承、多态
- 继承：基类、派生类、子类、父类、超类、重载
- 命名空间：程序作用域的表达
- 构造和析构：生成对象和删除对象的过程
```

### 类的构建

图片

类的基本构建方法

```shell
使用class 保留字定义类
class <类名>：
	[类描述：“documentation string”]
	<语句块>
类定义不限位置，可以包含在分支及其他从属语句块中，执行时存在即可

- 类的名字：可以使用任意字符，建议采用大写单词的组合
	如：ClassName，BasicAuto
- 类的描述：在类定义后首行，以独立字符串形式定义
	定义后通过<类名>.__doc__ 属性访问

类对象：class object
- 类定义完成之后，默认生成一个类对象
- 每个类唯一对应一个类对象，用于存储这个类的基本信息
- 类对象是type类的实例，表达为type类型

类的使用方法
	通过创建实例对象（instance Object）使用类的功能
	<对象名> = <类名>([<参数>])
	进一步采用<对象名>.<属性名> 和 <对象名>.<方法名>（） 体现类的功能
类的构造函数
- 类的构造函数用于从类创建实例对象的过程
- 类的构造函数为实例对象提供了参数的输入方式
- 类的构造函数为实例属性的定义和赋值提供了支持
类的属性和方法
- 类的属性：类中定义的变量，用来描述类的一些特性参数
- 类的方法：类中定义且与类相关的函数，用来给出类的操作功能
- 属性和方法是类对外交互通过的两种接口方式
```

#### 类的构造函数

```shell
__init__()的使用说明
- 参数：第一个采纳数约定是self，表示实例本身，其他参数是实例参数
- 函数名：python解释器内部定义，由双下划线(__)开始和结束
- 返回值：构造函数没有返回值，或返回None，否则产生TypeError错误

self在类定义内部代表类的实例
- self是python面对对象中约定的一个类参数
- self代表类的实例，在类内部，self用于组合访问实例相关的属性和方法
- 相比，类名称代表类对象本身
```

#### 类的属性

```python
属性是类内部定义的变量
- 类属性：类对象的属性，由所有实例对象所提供
- 实例属性：实例对象的属性，由个实例对象所独享

属性是类内部定义的变量
class <类名>:
    <类属性> = <类属性值>
    def __init__(self,<参数列表>)：
    	self.<实例属性名> = <实例属性值>
- 类属性：类对象的属性，由所有实例对象所共享
       访问：<类名>.<属性名> 或<对象名>.<属性名>
- 实例属性：实例对象的属性，由各实例对象所独享
		访问：<对象名>.<实例属性>
```

#### 类的方法

```shell
方法是类内部定义的函数
- 实例方法：实例对象的方法，由各实例对象独享，最常用的形式
- 类方法：类对象的方法，由各实例对象共享
- 自由方法：类中的一个普通函数，由类所在的命名空间管理，类对象独享
- 静态方法：类中的一个普通函数，由类对象和实例对象共享
- 保留方法：由双下划线开始和结束的方法，保留使用，如：__len__()
```

```shell
# 实例方法
class <类名>:
	def <方法名>(self,<参数列表>):
		.....
实例方法采用 <对象名>.<方法名>(参数)方式使用
```

```shell
# 类方法
类方法是与类对象相关的函数，由所有实例对象共享
class <类名>:
	@classmethos
	def <方法名>(cls,<参数列表>)：
		....
类方法采用<类名>.<类方法>(<参数列表>) 或<对象名>.<方法名>(<参数列表>)方式使用

- 类方法至少包含一个参数，表示类对象，建议使用cls
- @classmethod 是装饰器，类方法定义所必须
- 类方法只能操作类属性和其他类方法，不能操作实例属性和实例方法
```

```shell
# 自由方法
class <类名>:
	def <方法名>(<参数列表>):
		....
自由方法采用<类名>.<方法名>(<参数列表>) 方式使用，<类名> 表示名称空间

- 自由方法不需要self和cls这类参数，可以没有参数
- 自由方法只能操作类属性和类方法，不能操作实例属性和实例方法
- 自由方法的使用<类名>
```

```shell
# 静态方法
class <类名>:
	@staticmethod
	def <方法名>(<参数列表>):
		....
静态方法采用<类名>.<方法名>(<参数列表>) 或<对象名>.<方法名>(<参数列表>)方式使用

- 静态方法可以没有参数，可以理解为定义在类中的普通函数
- @staticmethod 是装饰器，静态方法定义所必须
- 静态方法只能操作类属性和其他类方法，不能操作实例属性和实例方法
- 相比于自由方法，静态方法能够使用<类名>和<对象名>两种方式使用
```

```shell
# 保留方法
class <类名>:
	def __<保留方法名>__(<参数列表>):
		....

```

### 类的析构函数

```shell
python使用预定义的__del__()作为析构函数
class 类名:
	def __del__(self):
		<语句块>
析构函数在`真实`删除实例对象时调用
使用del删除对象且对象被真实删除时调用析构函数__del__()

- 函数名和参数：python解释器内部约定，保留方法
- 调用方法：当实例对象被`真实删除`时，才调用该函数内语句
- 真实删除：当对象的引用为0或 当前程序退出（垃圾回收）
```

#### python类的内存管理

```shell
实例对象：正式创建的对象，分配对象内存
实例引用：实例的指针，仅分配指针内存

- 在删除对象前，python解释器会检查引用次数
- 引用次数不为0，则仅删除当前引用，0，则删除对象
- 如果程序退出，则由垃圾回收机制删除对象

sys.getrefcount(对象名)获得对象的引用次数
- 返回对象引用次数的方法，辅助删除对象时的分析
- sys.getrefcount() 函数返回值为 被引用值+1
- 非特定目的，不建议自己撰写析构函数，利用python的垃圾回收机制
```

### 类的封装

#### 封装的理解

```shell
封装Encapsulate：属性和方法的抽象
- 属性的抽象：对类的属性(变量)进行定义、隔离及保护
- 方法的抽象：对类的函数(方法)进行定义、隔离及保护
- 目的是形成一个类对外可操作属性及方法的接口

类(Class)
	- 属性(Attributes)
		- 私有属性：只能在类内部访问
		- 公开属性：可以通过类/对象名访问
	- 方法(Methods)
		- 私有方法：只能在类内部使用
		- 公开方法：可以通过类/对象名访问
- 属性的抽象：可以选择公开或隐藏属性，隐藏属性的内在机理
- 方法的抽象：可以选择公开或抽象方法，隐藏方法的内部逻辑
- 封装：让数据和代码成为类的过程，表达为：类-属性-方法
```

#### 私有属性和公开属性

```md
- 公开类属性：即类属性
- 私有类属性：仅当前类访问的类属性，子类不能访问，区别：私有类属性开始需要由两个下划线(__),如__count
	- 只能在类的内部被方法所访问
	- 不能通过<类名>.<属性名> 或 <对象名>.<属性名>方式访问
	- 有效的保证属性的可控性
- 公开实例属性
- 私有实例属性：仅供当前类内部访问的实例属性，子类也不能访问
	- 只能在类的内部被方法所访问
	- 不能通过<类名>.<属性名> 或 <对象名>.<属性名>方式访问
	- 有效的保证属性的可控性
```

#### 私有方法和公开方法

```shell
只要在类名称前面加上 __ 就是私有方法
- 各类方法都可以通过增加双下划线变为私有方法
- 私有方法从形式上保护Python类内部使用的函数逻辑
- 私有和公开是程序员逻辑，不是安全逻辑，重视约定
```

#### 类的保留属性

```shell
python解释器预留的类属性，以双下滑线开头和结尾
- 也叫:特殊属性，Special Attributes
- 特点：双下划线开头和结尾
- 作用：为理解python类提供了统一的属性接口
- 属性值：具有特定含义，类定义后直接使用
```

#### 仅用类名访问的保留属性

| 保留属性         | 描述                                    |
| ---------------- | --------------------------------------- |
| \_\_name\_\_     | 类的名称                                |
| \_\_qualname\_\_ | 以`.`分隔从模块全局命名空间开始的类名称 |
| \_\_bases\_\_    | 类所继承的基类名称                      |

#### 保留属性

| 保留属性            | 描述                                                     |
| ------------------- | -------------------------------------------------------- |
| <类>.\_\_dict\_\_   | 包含类成员信息的字典，key是属性和方法的名称，value是地址 |
| <对象>.\_\_dict\_\_ | 包含对象对象属性信息的字典，key是属性名称，value是值     |
| `__class__`         | 对象所对应的类信心，即type信息                           |
| `__doc__`           | 类描述，写在类定义下的首行字符串，不能继承               |
| `__module__`        | 类所在模块的名称                                         |
|                     |                                                          |

#### 类的保留方法

```shell
python解释器预留的类方法，以双下划线开头和结尾

- 也叫特殊方法：Special Methods
- 特点：双下划线开头和结尾
- 作用：为理解python类提供了统一的属性接口
- 属性值：具有特定含义，一般与操作符相关，类定义需要重载
```

基本类别

| 保留方法             | 对应操作          | 描述                             |
| -------------------- | ----------------- | -------------------------------- |
| `obj.__init__()`     | obj = ClassName() | 初始化实例对象的函数逻辑         |
| `obj.__del__()`      | del obj           | 删除实例对象的函数逻辑           |
| `obj.__repr__()`     | repr(obj)         | 定义对象可打印字符串的函数逻辑   |
| `obj.__str__()`      | str(obj)          | 定义对象字符串转操作的函数逻辑   |
| `obj.__bytes__()`    | bytes(obj)        | 定义对象字符串转换操作的函数逻辑 |
| `obj.__format__()`   | obj.format()      | 定义对象格式化输出的函数逻辑     |
| `obj.__hash__()`     | hash(obj)         | 定义对象哈希操作的函数逻辑       |
| `obj.__bool__()`     | bool(obj)         | 定义对象布尔运算的函数逻辑       |
| `obj.__len__()`      | len(obj)          | 定义对象长度操作的函数           |
| `obj.__reversed__()` | obj.reversed()    | 定义对象逆序的函数逻辑           |
| `obj.__abs__()`      | abs(obj)          | 定义对象绝对值操作的函数逻辑     |
| `obj.__int__()`      | int(obj)          | 定义对象整数转换的函数逻辑       |

#### 比较操作

| 保留方法       | 对应操作     | 描述                         |
| -------------- | ------------ | ---------------------------- |
| `onj.__lt__()` | obj1 < obj2  | 对象之间的比较操作的保留方法 |
| `obj.__le__()` | obj1 <= obj2 |                              |
| `obj.__eq__()` | obj1 == obj2 |                              |
| `obj.__ne__()` | obj1 != obj2 |                              |
| `obj.__gt__()` | obj1 > obj2  |                              |
| `obj.__ge__()` | obj1 >= obj2 |                              |

保留方法使用说明

```shell
- python 保留了超过100个各种保留方法
- 保留方法对应对象、对象间、对象方法的各种操作
```

### 类的继承

#### 继承的理解

```shell
继承 inheritance ：代码复用的高级抽象

- 继承是面对对象程序设计的精髓之一
- 实现了以类为单位的高抽象级代码复用
- 继承是新定义类能够完全使用原有类属性与方法的过程
```

#### 最基础类

```shell
object类是python所有类的基类
- object 是python最基础类的名字
- 所有类定义时默认继承object类
- 保留属性和保留方法本质是object类的属性和方法

python对象的三个要素：标识、类型和值
- 标识 identity：对象一旦构建不会改变，用id()获得，一般是内存地址
- 类型type：对象的类型，同type() 获得
- 值value： 分为可变mutable与不可变immutable两种
```

| 函数/保留字 | 描述                                              |
| ----------- | ------------------------------------------------- |
| id(x)       | 返回x的标识，Cpython用内存地址表示                |
| x is y      | 判断x和y的标识是否相等，返回True、False，不判断值 |

#### 类的属性重载

```shell
重载：派生类对基类属性或方法的再定义
- 属性重载：派生类定义并使用与基类相同名称的属性
- 方法重载：派生类定义并使用了与基类相同名称的方法

最近覆盖原则，重载无需特殊标记
- 步骤一、优先使用派生类定义的属性和方法
- 步骤二、然后寻找基类的属性和方法
- 步骤三、再寻找超类的属性和方法
```

#### 类的方法重载

```shell
方法重载：派生类对基类方法的再定义
- 完全重载：派生类完全重定义与基类相同名称的方法
	直接在派生类中定义同名方法即可
- 增量重载：派生类扩展定义与基类相同名称的方法

增量重载：使用super()方法
	class 派生类名(基类)：
		def 方法名(self,参数列表):
			super().基类方法名(参数列表)
			...
```

类的多继承

```shell
多继承的构建：在定义类时声明继承关系
class <类名>(<基类名称1>,<基类名称2>,<基类名称3>):
	def __init__(self，参数列表):
		代码块
python3采用广度优先优先，从左至右实施多继承
```

类继承的构建

```shell
在定义类时声明继承关系
class 类名(基类名):
	def __init__(self,参数列表):
		语句块

派生类可以直接使用基类的属性和方法
- 基类的属性基本等同于 定义在派生类中
- 派生类可以直接使用基类的类属性，实例属性
- 派生类可以直接使用基类的各种方法
- 使用基类的类方法和类属性时，要用基类的类名调用

派生类的约束
- 派生类只能继承基类的公开属性和方法
- 派生类不能继承基类的私有属性和方法
```

| 函数                  | 描述                                                    |
| --------------------- | ------------------------------------------------------- |
| isinstance(obj,cls)   | 判断对象obj是否是类cls的实例或子类实例，返回True或False |
| issubclass(cls1,cls2) | 判断类cls1是否是cls2的子类，返回True或False             |

python类的运算

python类的多态

python对象的引用

python类的高级话题























































