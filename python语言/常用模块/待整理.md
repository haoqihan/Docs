pip的使用

```shell
# 安装
pip install jieba   或 pip install jieba-0.39.zip

# 更新
pip install -U jieba

# 卸载
pip uninstall jieba

# 只下载，不安装
pip download jieba

# 查看第三方库详情
pip show jieba

# 根据关键词在名称和介绍中搜索第三方库
pip search blockchain

# 列出当前系统安装的第三方库
pip list

# 指定当前用户
pip install  --user jieba
```

uci 安装

```shell
网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/

uci安装的三个步骤
    步骤一、在UCI页面搜索对应的第三方库
    步骤二、下载对应python解释器的编译后的版本
    步骤三、本地安装pip install <下载文件名>
```

pip安装脚本



第三方解析库

```shell
1.pyinstaller 
2.jieba
3.wordcloud
```

pyinstaller库的使用

```shell
pyinstaller 将py文件源代码转换为可执行文件的功能
```

使用

```shell
pyinstaller -F <文件名.py>
pyinstaller [options] script [script..]
```

命令说明

| 选项                 | 选项说明                                   |
| -------------------- | ------------------------------------------ |
| -h 或--help          | 显示帮助信息                               |
| -v 或--version       | 显示版本信息                               |
| --dispath dir        | 制定输出目录，默认是./dist                 |
| --workpath wdir      | 指定临时存储文件的目录，默认是./build      |
| -y 或--noconfirm     | 强制替换输出目录内容，没有确认询问         |
| -D 或--onedir        | 创建一个目录，包含可执行程序和程序依赖文件 |
| -F 或onefile         | 创建一个独立的可执行文件                   |
| -n NAME 或-name NAME | 指定输出文件的名称目录                     |
| -i  <图标文件名.ico> | 指定打包程序使用的图标（ico） 文件         |

jieba库的使用

介绍

```shell
中文文本需要通过分词获得单个词语的信息
jieba库提供三种分词模式，支持自定义词典
```

```shel
# 三种分词模式
- 精确模式：将文本精确切开，分词无冗余，适合文本分词
- 全模式：把文本中所有可能成词的词语扫描出来，速度快，不能解决歧义
- 搜索引擎模式：在精确模式基础上，对长词再次切分，提高召回率
```

| 函数                            | 描述                                                       |
| ------------------------------- | ---------------------------------------------------------- |
| jieba.cut(s)                    | 精确模式，分词后返回一个迭代器，用for..in 形式便利结果     |
| jieba.lcut(s)                   | 精确模式，分词后返回一个列表                               |
| jieba.cut(s，cut_all=True)      | 全模式，分词返回一个迭代器，用for..in 形式便利结果         |
| jieba.cut(s，cut_all=True)      | 全模式，分词后返回一个列表                                 |
| jieba.cut_for_search("新时代")  | 搜索引擎模式，分词后返回一个迭代器，用for..in 形式便利结果 |
| jieba.lcut_for_search("新时代") | 搜索引擎模式，分词后返回一个列表                           |
| jieba.add_word(w)               | 向分词词典增加新词w                                        |

### wordcloud库的使用

介绍

```shell
wordcloud.WordCloud() 代表一个文本对应的词云
可以根据文本中词语出现的频率等参数绘制词云
绘制词云的形状、尺寸和颜色等可以设定
```

常用用法

```python
w = wordcloud.WordCloud() 
以WordCloud对象为基础
配置参数、加载文本、输出文件
```

方法

| 方法                | 描述                             |
| ------------------- | -------------------------------- |
| w.generate(txt)     | 向WordCloud对象w中加载文本txt    |
| w.to_file(filename) | 将词云输出为图像文件，.png或.jpg |
|                     |                                  |

WordCloud参数

| 参数             | 描述                                                       |
| ---------------- | ---------------------------------------------------------- |
| width            | 指定词云对象生成图片的宽度，默认为400像素                  |
| height           | 指定词云对象生成图片的高度，默认为200像素                  |
| min_font_size    | 指定词云中最小字号，默认为4号                              |
| max_font_size    | 指定词云中字体的最大字号，根据高度自动调节                 |
| font_step        | 指定词云中字体字号的步进间隔，默认为1                      |
| font_path        | 指定字体文件的路径，默认为None  例子：font_path=“msyh.ttc” |
| mask             | 指定词云形状，需要引用 imread() 函数，默认为长方形         |
| background_color | 指定词云的背景颜色                                         |
|                  |                                                            |

例子：

```python
import wordcloud
w = wordcloud.WordCloud()  # 步骤一、配置对象参数
w.generate("one python")   # 步骤二、加载词云文本
w.to_file("zz.png")       # 步骤三、输出词云文件
```



### pipenv的使用

介绍

```shell
pipenv库提供基于项目的虚拟环境维护及python库管理功能
- 以项目为单位隔离python环境，进而使用不同的python库版本
- 自动管理安装python库及其他依赖库
- 命令行工具：基于virtualenv和pip，目前最好用的虚拟环境维护工具
```

原理

```shell
pipenv 库使用pipfile 和Pipfile.lock 来管理虚拟环境
- Pipfile：记录虚拟环境信息，尤其是python库
- pipfile.lock 锁定python库版本
- 两个文件共同表达了虚拟环境
```

基本使用

```shell
pipenv --three  或 pipenv --python 3.6 # 建立python3.6的环境
pipenv shell # 进入虚拟环境命令行
pipenv install  jieba   # 安装第三方库
pipenv graph  # 展示虚拟环境中的库依赖
pipenv run  xx.py  # 使用虚拟环境执行文件
exit # 退出虚拟环境
```

### tabulate库的使用

介绍

```shel
tabulate 库提供优雅打印表格数据的功能
- 支持二位列表、二维迭代类型、字典迭代等类型
- 支持Numpy二维数组、pandas.DataFrame 类型
- 输出表格可以通过参数自定义风格
```

基本使用

```python
from tabulate import tabulate
tabulate(table,headers,tablefmt,numalign)
	- table:表格数据或变量
	- headers 定义表格的表头
    - tablefmt 定义表格风格
    - numalign 设置全表格数字的对其方式，默认智能对其
plain 	rest 		simple 		mediawiki
grid  	moinmoin 	fancy_grid	youtrack
pipe	html		orgtbl		latex
jira	latex_raw	presto		latex_booktabs	
psql	textile
```

### QRcode库的使用

介绍

```shell
QRcode库提供二维码生成功能
- 支持各种类数据的二维码生成
img = make(txt,border=4)
- txt:待转变为二维码的字符或字符串
- border：设置二维码边的宽度
- img：一个PIL库类型的图像句柄
```

实例

```shell
>>> import qrcode
>>> img = qrcode.make("http://www.baidu.com")
>>> img.save("百度二维码.png"）
```

## 面对对象

### 编程模式

```shell
python语言的“万物皆对象”
- python语言中所有的数据类型都是对象，函数是对象，模块是对象
- python所有的类都继承于基础类object
- python语言中数据类型的操作功能都是类方法的体现

OOP：object-Oriented Programming
- OOP：面对对象编程，一种编程思想，重点在于高抽象的复用代码
- OOP把对象当做程序的基本单元，对象包含数据和操作数据的函数
- OOP的本质是把问题抽象为以对象为中心的计算机程序
- OOP在较大规模或复杂项目中十分有用，OOP可以提高协作产量
- OOP主要价值在于代码的复用
- OOP只是一种编程模式，非解决问题的高级方法

面向过程 VS 面向对象
- 面向过程：以解决问题的过程步骤为核心编写程序的方式
- 面向对象：以对象构建和应用为核心的编写程序的方式
- 所有OOP能解决的事情，面向过程也能解决

面向对象的三大特征
- 封装：属性和方法的抽象，用数据和操作数据的方法来形成对象逻辑
- 继承：代码复用的高级抽象，用对象之间的继承关系来形成代码复用
- 多态：方法灵活性的抽象，让对象的操作更加灵活，更多复用代码

封装 Encapsulate ：属性和方法的抽象
- 属性的抽象：对类的属性(变量)进行定义，隔离及保护
- 方法的抽象：对类的方法(函数)进行定义、隔离及保护
- 目标是形成一个类对外可操作属性和方法的接口

继承 inheritance ：代码复用的高级抽象
- 继承是面对对象设计的精髓之一
- 实现以类为单位的高抽象级别代码复用
- 继承是新定义的类能够几乎完全使用原有类属性和方法的过程

多态 Polymorphism ：针对方法、方法灵活性的抽象
- 参数类型的多态：一个方法能够处理多个类型的能力
- 参数形式的多态：一个方法能够处理多个参数的能力
- 多态是OOP的一个传统概念，Python天然支持多态，不需要特殊语法
```

常用术语

```shell
类Class 和 对象 Object
- 类：逻辑抽象和产生对象的模板，一组变量和函数的特定编排
- 对象：具体表达数据及操作的实体，相当于程序中的“变量”
- 实例化：从类到对象的过程，所有“对象”都源于某个“类”

面对对象术语概念
- 对象：类对象、实例对象
- 属性：存储数据的”变量“，包括：类属性、实例属性
- 方法：操作数据的“函数”
	包括：类方法、实例方法、自由方法、静态方法、保留方法

类对象 VS 实例对象
- 类对象：class Object ，维护每个python类基本信息的数据结构
- 实例对象：instance Object，python类实例后产生的对象，简称“对象”
- 这是一组概念，类对象全局只有一个，实例对象可以生成多个

- 三个特性：封装继承、多态
- 继承：基类、派生类、子类、父类、超类、重载
- 命名空间：程序作用域的表达
- 构造和析构：生成对象和删除对象的过程
```

### 类的构建

图片

类的基本构建方法

```shell
使用class 保留字定义类
class <类名>：
	[类描述：“documentation string”]
	<语句块>
类定义不限位置，可以包含在分支及其他从属语句块中，执行时存在即可

- 类的名字：可以使用任意字符，建议采用大写单词的组合
	如：ClassName，BasicAuto
- 类的描述：在类定义后首行，以独立字符串形式定义
	定义后通过<类名>.__doc__ 属性访问

类对象：class object
- 类定义完成之后，默认生成一个类对象
- 每个类唯一对应一个类对象，用于存储这个类的基本信息
- 类对象是type类的实例，表达为type类型

类的使用方法
	通过创建实例对象（instance Object）使用类的功能
	<对象名> = <类名>([<参数>])
	进一步采用<对象名>.<属性名> 和 <对象名>.<方法名>（） 体现类的功能
类的构造函数
- 类的构造函数用于从类创建实例对象的过程
- 类的构造函数为实例对象提供了参数的输入方式
- 类的构造函数为实例属性的定义和赋值提供了支持
类的属性和方法
- 类的属性：类中定义的变量，用来描述类的一些特性参数
- 类的方法：类中定义且与类相关的函数，用来给出类的操作功能
- 属性和方法是类对外交互通过的两种接口方式
```

#### 类的构造函数

```shell
__init__()的使用说明
- 参数：第一个采纳数约定是self，表示实例本身，其他参数是实例参数
- 函数名：python解释器内部定义，由双下划线(__)开始和结束
- 返回值：构造函数没有返回值，或返回None，否则产生TypeError错误

self在类定义内部代表类的实例
- self是python面对对象中约定的一个类参数
- self代表类的实例，在类内部，self用于组合访问实例相关的属性和方法
- 相比，类名称代表类对象本身
```

#### 类的属性

```python
属性是类内部定义的变量
- 类属性：类对象的属性，由所有实例对象所提供
- 实例属性：实例对象的属性，由个实例对象所独享

属性是类内部定义的变量
class <类名>:
    <类属性> = <类属性值>
    def __init__(self,<参数列表>)：
    	self.<实例属性名> = <实例属性值>
- 类属性：类对象的属性，由所有实例对象所共享
       访问：<类名>.<属性名> 或<对象名>.<属性名>
- 实例属性：实例对象的属性，由各实例对象所独享
		访问：<对象名>.<实例属性>
```

#### 类的方法

```shell
方法是类内部定义的函数
- 实例方法：实例对象的方法，由各实例对象独享，最常用的形式
- 类方法：类对象的方法，由各实例对象共享
- 自由方法：类中的一个普通函数，由类所在的命名空间管理，类对象独享
- 静态方法：类中的一个普通函数，由类对象和实例对象共享
- 保留方法：由双下划线开始和结束的方法，保留使用，如：__len__()
```

```shell
# 实例方法
class <类名>:
	def <方法名>(self,<参数列表>):
		.....
实例方法采用 <对象名>.<方法名>(参数)方式使用
```

```shell
# 类方法
类方法是与类对象相关的函数，由所有实例对象共享
class <类名>:
	@classmethos
	def <方法名>(cls,<参数列表>)：
		....
类方法采用<类名>.<类方法>(<参数列表>) 或<对象名>.<方法名>(<参数列表>)方式使用

- 类方法至少包含一个参数，表示类对象，建议使用cls
- @classmethod 是装饰器，类方法定义所必须
- 类方法只能操作类属性和其他类方法，不能操作实例属性和实例方法
```

```shell
# 自由方法
class <类名>:
	def <方法名>(<参数列表>):
		....
自由方法采用<类名>.<方法名>(<参数列表>) 方式使用，<类名> 表示名称空间

- 自由方法不需要self和cls这类参数，可以没有参数
- 自由方法只能操作类属性和类方法，不能操作实例属性和实例方法
- 自由方法的使用<类名>
```

```shell
# 静态方法
class <类名>:
	@staticmethod
	def <方法名>(<参数列表>):
		....
静态方法采用<类名>.<方法名>(<参数列表>) 或<对象名>.<方法名>(<参数列表>)方式使用

- 静态方法可以没有参数，可以理解为定义在类中的普通函数
- @staticmethod 是装饰器，静态方法定义所必须
- 静态方法只能操作类属性和其他类方法，不能操作实例属性和实例方法
- 相比于自由方法，静态方法能够使用<类名>和<对象名>两种方式使用
```

```shell
# 保留方法
class <类名>:
	def __<保留方法名>__(<参数列表>):
		....

```

### 类的析构函数

```shell
python使用预定义的__del__()作为析构函数
class 类名:
	def __del__(self):
		<语句块>
析构函数在`真实`删除实例对象时调用
使用del删除对象且对象被真实删除时调用析构函数__del__()

- 函数名和参数：python解释器内部约定，保留方法
- 调用方法：当实例对象被`真实删除`时，才调用该函数内语句
- 真实删除：当对象的引用为0或 当前程序退出（垃圾回收）
```

#### python类的内存管理

```shell
实例对象：正式创建的对象，分配对象内存
实例引用：实例的指针，仅分配指针内存

- 在删除对象前，python解释器会检查引用次数
- 引用次数不为0，则仅删除当前引用，0，则删除对象
- 如果程序退出，则由垃圾回收机制删除对象

sys.getrefcount(对象名)获得对象的引用次数
- 返回对象引用次数的方法，辅助删除对象时的分析
- sys.getrefcount() 函数返回值为 被引用值+1
- 非特定目的，不建议自己撰写析构函数，利用python的垃圾回收机制
```

### 类的封装

#### 封装的理解

```shell
封装Encapsulate：属性和方法的抽象
- 属性的抽象：对类的属性(变量)进行定义、隔离及保护
- 方法的抽象：对类的函数(方法)进行定义、隔离及保护
- 目的是形成一个类对外可操作属性及方法的接口

类(Class)
	- 属性(Attributes)
		- 私有属性：只能在类内部访问
		- 公开属性：可以通过类/对象名访问
	- 方法(Methods)
		- 私有方法：只能在类内部使用
		- 公开方法：可以通过类/对象名访问
- 属性的抽象：可以选择公开或隐藏属性，隐藏属性的内在机理
- 方法的抽象：可以选择公开或抽象方法，隐藏方法的内部逻辑
- 封装：让数据和代码成为类的过程，表达为：类-属性-方法
```

#### 私有属性和公开属性

```md
- 公开类属性：即类属性
- 私有类属性：仅当前类访问的类属性，子类不能访问，区别：私有类属性开始需要由两个下划线(__),如__count
	- 只能在类的内部被方法所访问
	- 不能通过<类名>.<属性名> 或 <对象名>.<属性名>方式访问
	- 有效的保证属性的可控性
- 公开实例属性
- 私有实例属性：仅供当前类内部访问的实例属性，子类也不能访问
	- 只能在类的内部被方法所访问
	- 不能通过<类名>.<属性名> 或 <对象名>.<属性名>方式访问
	- 有效的保证属性的可控性
```

#### 私有方法和公开方法

```shell
只要在类名称前面加上 __ 就是私有方法
- 各类方法都可以通过增加双下划线变为私有方法
- 私有方法从形式上保护Python类内部使用的函数逻辑
- 私有和公开是程序员逻辑，不是安全逻辑，重视约定
```

#### 类的保留属性

```shell
python解释器预留的类属性，以双下滑线开头和结尾
- 也叫:特殊属性，Special Attributes
- 特点：双下划线开头和结尾
- 作用：为理解python类提供了统一的属性接口
- 属性值：具有特定含义，类定义后直接使用
```

#### 仅用类名访问的保留属性

| 保留属性         | 描述                                    |
| ---------------- | --------------------------------------- |
| \_\_name\_\_     | 类的名称                                |
| \_\_qualname\_\_ | 以`.`分隔从模块全局命名空间开始的类名称 |
| \_\_bases\_\_    | 类所继承的基类名称                      |

#### 保留属性

| 保留属性            | 描述                                                     |
| ------------------- | -------------------------------------------------------- |
| <类>.\_\_dict\_\_   | 包含类成员信息的字典，key是属性和方法的名称，value是地址 |
| <对象>.\_\_dict\_\_ | 包含对象对象属性信息的字典，key是属性名称，value是值     |
| `__class__`         | 对象所对应的类信心，即type信息                           |
| `__doc__`           | 类描述，写在类定义下的首行字符串，不能继承               |
| `__module__`        | 类所在模块的名称                                         |
|                     |                                                          |

#### 类的保留方法

```shell
python解释器预留的类方法，以双下划线开头和结尾

- 也叫特殊方法：Special Methods
- 特点：双下划线开头和结尾
- 作用：为理解python类提供了统一的属性接口
- 属性值：具有特定含义，一般与操作符相关，类定义需要重载
```

基本类别

| 保留方法             | 对应操作          | 描述                             |
| -------------------- | ----------------- | -------------------------------- |
| `obj.__init__()`     | obj = ClassName() | 初始化实例对象的函数逻辑         |
| `obj.__del__()`      | del obj           | 删除实例对象的函数逻辑           |
| `obj.__repr__()`     | repr(obj)         | 定义对象可打印字符串的函数逻辑   |
| `obj.__str__()`      | str(obj)          | 定义对象字符串转操作的函数逻辑   |
| `obj.__bytes__()`    | bytes(obj)        | 定义对象字符串转换操作的函数逻辑 |
| `obj.__format__()`   | obj.format()      | 定义对象格式化输出的函数逻辑     |
| `obj.__hash__()`     | hash(obj)         | 定义对象哈希操作的函数逻辑       |
| `obj.__bool__()`     | bool(obj)         | 定义对象布尔运算的函数逻辑       |
| `obj.__len__()`      | len(obj)          | 定义对象长度操作的函数           |
| `obj.__reversed__()` | obj.reversed()    | 定义对象逆序的函数逻辑           |
| `obj.__abs__()`      | abs(obj)          | 定义对象绝对值操作的函数逻辑     |
| `obj.__int__()`      | int(obj)          | 定义对象整数转换的函数逻辑       |

保留方法使用说明

```shell
- python 保留了超过100个各种保留方法
- 保留方法对应对象、对象间、对象方法的各种操作
```

### 类的继承

#### 继承的理解

```shell
继承 inheritance ：代码复用的高级抽象

- 继承是面对对象程序设计的精髓之一
- 实现了以类为单位的高抽象级代码复用
- 继承是新定义类能够完全使用原有类属性与方法的过程
```

#### 最基础类

```shell
object类是python所有类的基类
- object 是python最基础类的名字
- 所有类定义时默认继承object类
- 保留属性和保留方法本质是object类的属性和方法

python对象的三个要素：标识、类型和值
- 标识 identity：对象一旦构建不会改变，用id()获得，一般是内存地址
- 类型type：对象的类型，同type() 获得
- 值value： 分为可变mutable与不可变immutable两种
```

| 函数/保留字 | 描述                                              |
| ----------- | ------------------------------------------------- |
| id(x)       | 返回x的标识，Cpython用内存地址表示                |
| x is y      | 判断x和y的标识是否相等，返回True、False，不判断值 |

#### 类的属性重载

```shell
重载：派生类对基类属性或方法的再定义
- 属性重载：派生类定义并使用与基类相同名称的属性
- 方法重载：派生类定义并使用了与基类相同名称的方法

最近覆盖原则，重载无需特殊标记
- 步骤一、优先使用派生类定义的属性和方法
- 步骤二、然后寻找基类的属性和方法
- 步骤三、再寻找超类的属性和方法
```

#### 类的方法重载

```shell
方法重载：派生类对基类方法的再定义
- 完全重载：派生类完全重定义与基类相同名称的方法
	直接在派生类中定义同名方法即可
- 增量重载：派生类扩展定义与基类相同名称的方法

增量重载：使用super()方法
	class 派生类名(基类)：
		def 方法名(self,参数列表):
			super().基类方法名(参数列表)
			...
```

类的多继承

```shell
多继承的构建：在定义类时声明继承关系
class <类名>(<基类名称1>,<基类名称2>,<基类名称3>):
	def __init__(self，参数列表):
		代码块
python3采用广度优先优先，从左至右实施多继承
```

类继承的构建

```shell
在定义类时声明继承关系
class 类名(基类名):
	def __init__(self,参数列表):
		语句块

派生类可以直接使用基类的属性和方法
- 基类的属性基本等同于 定义在派生类中
- 派生类可以直接使用基类的类属性，实例属性
- 派生类可以直接使用基类的各种方法
- 使用基类的类方法和类属性时，要用基类的类名调用

派生类的约束
- 派生类只能继承基类的公开属性和方法
- 派生类不能继承基类的私有属性和方法
```

| 函数                  | 描述                                                    |
| --------------------- | ------------------------------------------------------- |
| isinstance(obj,cls)   | 判断对象obj是否是类cls的实例或子类实例，返回True或False |
| issubclass(cls1,cls2) | 判断类cls1是否是cls2的子类，返回True或False             |

### python类的运算

#### 运算的理解

```shell
运算 Operation：操作逻辑的抽象
- 运算体现一种操作逻辑，广义角度，任何程序都被认为运算
- Python解释器通过保留方法预留了一批运算接口，需要重载
- 保留方法一般对应运算符，Python中运算体现为运算符的重载
运算重载的限制
- 不能重载Python语言内置的运算符
- 不能新建运算符，只能通过重载完成
- is and not or 不能被重载
```

#### 算数运算的重载

```shell
算数运算符的种类
- 一元运算符：`+、-、～`
- 二元运算符：`+、-、*、/、//、%、divmod()、pow()、**、<< 、>> 、&、^、|`
```

###### 一元运算符的重载

| 保留方法           | 对应操作 | 描述                     |
| ------------------ | -------- | ------------------------ |
| `__neg__(self)`    | -obj     | 定义对象取负的运算逻辑   |
| `__pos__(self)`    | +obj     | 定义对象取正的运算逻辑   |
| `__abs__(self)`    | abs(obj) | 定义对象绝对值的运算逻辑 |
| `__invert__(self)` | ~obj     | 定义对象取反的运算逻辑   |

二元运算符

| 保留方法                   | 对应操作          | 描述                         |
| -------------------------- | ----------------- | ---------------------------- |
| `__add__(self,other)`      | obj+ther          | 定义两个对象加法的运算逻辑   |
| `__sub__(self,other)`      | obj - other       | 定义两个对象减法的运算逻辑   |
| `__mul__(self,other)`      | obj * other       | 定义两个对象乘法的运算逻辑   |
| `__truediv__(self,other)`  | obj / other       | 定义两个对象除法的运算逻辑   |
| `__floordiv__(self,other)` | obj  // other     | 定义两个对象整除的运算逻辑   |
| `__mod__(self,other)`      | obj % other       | 定义两个对象的模运算逻辑     |
| `__divmod__(self,other)`   | divmod(obj,other) | 定义两个对象除模的运算逻辑   |
| `__pow__(self,other)`      | obj ** other      | 定义对象幂的运算逻辑         |
| `__lshift__(self,other)`   | obj << other      | 定义对象左移的运算逻辑       |
| `__rshift__(self,other)`   | obj >> other      | 定义对象右移的运算逻辑       |
| `__and__(self,other)`      | obj & other       | 定义两个对象位与的运算逻辑   |
| `__xor__(self,other)`      | obj ^ other       | 定义两个对象位异或的运算逻辑 |
| `__or__(self,other)`       | obj \| other      | 定义两个对象位或的运算逻辑   |

#### 比较运算的重载

```shell
比较运算的种类
- 比较运算：`< 、<= 、 ==、!= 、>、>=`
```

#### 比较操作

| 保留方法       | 对应操作     | 描述                         |
| -------------- | ------------ | ---------------------------- |
| `onj.__lt__()` | obj1 < obj2  | 对象之间的比较操作的保留方法 |
| `obj.__le__()` | obj1 <= obj2 |                              |
| `obj.__eq__()` | obj1 == obj2 |                              |
| `obj.__ne__()` | obj1 != obj2 |                              |
| `obj.__gt__()` | obj1 > obj2  |                              |
| `obj.__ge__()` | obj1 >= obj2 |                              |

#### 成员运算的重载

```shell
成员运算的种类
- 成员的获取:[]、del 、reversed()
- 成员的判断: in、 not in
```

| 保留方法                      | 对应操作       | 描述                                       |
| ----------------------------- | -------------- | ------------------------------------------ |
| `__getitem__(self,key)`       | obj[key]       | 定义获取对象中序号k元素的逻辑运算，k为整数 |
| `__setitem__(self,key,value)` | obj[key]=value | 定义赋值对象中序号k元素的逻辑运算          |
| `__delitem__(self,key)`       | del obj[k]     | 定义删除对象中序号k元素的运算逻辑          |
| `__recersed__(self)`          | obj.reversed() | 定义对象逆序的运算逻辑                     |
| `__contains__(self,item)`     | item in obj    | 定义in操作符对应的运算逻辑                 |

#### 其他运算的重载

| 保留方法                       | 对应操作                    | 描述                             |
| ------------------------------ | --------------------------- | -------------------------------- |
| `__repr__(self)`               | repr(obj)                   | 定义对象可打印字符串的运算逻辑   |
| `__str__(self)`                | str(obj)                    | 定义对象字符串转换操作的运算逻辑 |
| `__len__(self)`                | len(obj)                    | 定义对象长度操作的运算逻辑       |
| `__int__(self)`                | int(obj)                    | 定义对象整数转换的运算逻辑       |
| `__float__(self)`              | float(obj)                  | 定义对象浮点数类型转换的运算逻辑 |
| `__complex__(self)`            | complex(obj)                | 定义对象附属转换的运算逻辑       |
| `__round__(self)`              | round(obj)                  | 定义对象四舍五入的运算逻辑       |
| `__bytes__(self)`              | bytes(obj)                  | 定义对象字节串 转换的运算逻辑    |
| `__bool__()`                   | bool(obj)                   | 定义对象布尔值运算的运算逻辑     |
| `__format__(self,format_spec)` | obj.format()<br>format(obj) | 定义对象格式化输出的运算逻辑     |

### python类的多态

#### 多态的理解

```shell
多态 Polymorphism：仅针对方法，方法灵活性的抽象
- 参数类型的多态：一个方法能够处理多个类型的能力
- 参数形式的多态：一个方法能够接受多个参数的能力
- 多态是OOP的一个传统概念，Python天然支持多态，不需要特殊语法
```

#### 参数类型的多态

```shell
天然支持：Python方法无类型声明限制
- python的函数/方法没有类型声明限制，天然支持参数类型的多态性
- Python编程理念在于：文档约束
```

#### 参数形式的多态

```shell
天然支持：python方法、函数支持多种参数形式
- Python的函数、方法可以支持可变参数，支持参数形式的多态性
- python的类方法是函数，函数的各种定义均有效
- 对不同参数个数及默认值的确定，需要由程序员完成
```

### python对象的引用

#### 引用的理解

```shell
引用 Reference：对象的指针
- 引用的内存中真实对象的指针，表示为变量名或内存指针
- 每个对象存在至少一个引用，id()函数用于获取引用
- 在传递参数或赋值时，python传递对象的引用，而不是复制对象
- 不可变对象与可变对象的内存管理略有不同
```

```shell
python内部机制对引用的处理
- 不可变对象：immutable解释器为相同值维护尽量少的内存区域
- 可变对象：mutable解释器为每个对象维护不同内存区域
```

```shell
导致引用+1的情况
- 对象被创建： d = DemoClass()
- 对象被引用： a =b
- 对象被作为函数或方法的参数：sys.getrefcount(d)
- 对象被作为一个容器中的元素：ls = [d,]
```

```shell
导致引用-1的情况
- 对象被删除： del d
- 对象的名字被赋予新的对象 d = 123
- 对象离开作用域：foo()函数的局部变量count
- 对象所在的容器被删除：del ls
```

#### 浅拷贝和深拷贝

```shell
浅拷贝和深拷贝
- 拷贝：复制一个对象为新的对象，内存空间有“变化”
- 浅拷贝：仅复制最顶层对象的拷贝方式，默认拷贝方式
- 深拷贝：迭代复制所有对象的拷贝方式
```

```shell
完全拷贝对象内容
- 采用copy库的deepcopy()方法
- 迭代拷贝对象内各层次对象，完全新开辟内存建立对象
- 深拷贝仅针对可变类型，不可变类型无需创建新的对象
```

```shell
浅拷贝与深拷贝
- 浅拷贝：仅复制最顶层对象的拷贝方式，默认拷贝方式
- 深拷贝:迭代复制所有对象的拷贝方式,采用copy库的deepcopy方法
- 一般深拷贝都与可变类型关联
```

#### 类的方法引用

```shell
类的实例方法
- 定义方式:def <实例方法名>(self,<参数列表>):
- 实例方法名也是一种引用，即方法本身的引用
- 当方法引用时,方法(即函数)将产生一个对象:方法对象
```

### python类的高级话题

##### 命名空间的理解

```shell
命名空间 Namespace:从名字到对象的一种映射
- 作用域:全局变量名在模块命名空间，局部变量名在函数命名空间
- 属性和方法在类命名空间，名字全称：<命名空间>.<变量、函数名>
- 命名空间底层由dict实现，变量名是键，变量引用的对象是值

- 复数z,z.real和z.imag 是对象z命名空间的两个属性
- 对象d,d.name 和d.printName()是对象d命名空间的属性和方法
- global 和nonlocal 是两个声明命名空间的保留字
```

#### 类的特性装饰器

```shell
@property ：类的特性装饰器
- 使用@property把类中的方法变为对外可见的 "属性"
- 类内部：表现为方法
- 类外部：表现为属性
- @<方法名>.setter 用于设定属性的复赋值操作
```

#### 自定义异常类型

```shell
异常Exception 也是一种python类
- try-except 捕捉自定义的异常
- 继承Exception类,可以给出自定义的异常类
- 自定义异常是类继承的正常应用过程
```

#### 类的名称修饰

```shell
名称修饰 Name Mangling ：类的名称的变换约定
- python通过名称修饰完成一些重要的功能
- 采用下划线(_) 进行名称修饰
- _X、X_ 、__X、_X_、 _

_X :单下划线开头的名称修饰
- 单个下划线开头属性或方法为类内部使用 PEP8
- 只是约定，仍然可以通过<对象名>.<属性名>方式访问
- 功能： from xx import * 时不会导入下划线开头的属性和方法

X_ :单下划线结尾的名称修饰
- 单下划线结尾属性或方法为避免与保留字或已有命名冲突 PEP8
- 只是约定，无任何功能性对应

__X:双下滑线开头的名称修饰
- 双下划线开头属性或方法将被解释器修改名称，避免命名冲突
- 不是约定，而是功能性，实现私有属性，私有方法
- __X会改为：_<类名>__X

__x__:双下滑线开头和结尾的名称修饰
- 双下滑线开头和结尾的属性或方法无特殊功能，名字不能被修改
- 部分名称是保留属性或保留方法

_:单下划线
- 单个下划线是一个无关紧要的名字，无特殊功能
```

##### python最小空类

```python
# python最小空类
class <类名>():
	pass
python最小空类的作用
- 类是命名空间，最小空类可以当作命名空间使用
- 最小空类可以辅助数据存储和使用
- 动态增加属性是python类的一个特点
```

### 深入理解python库

#### 库、模块和包

```shell
库 library：一种对特定功能集合的通俗说法
- 包含一些程序功能，通过import 引入使用，对应模块和包
- 标准库：Standard Library，与python解释器一同安装的库
- 第三方库：Third-Party Library ，需要额外安装的库

模块 Module：以单个文件为命名空间的代码片段
- 模块是一个单独的py文件、模块名就是文件名
- 模块的本质是一个独立的，由模块名组织的命名空间
- 模块中可以引入其他模块，并由一些Python语法来约束和管理

包 Package：由一组模块构成、由层次命名空间的程序功能
- 包由多个模块（多个.py文件）有组织的构成
- 木块的组织方式构成了命名空间的层次结构
- 包是模块的上一级组织概念，其中可以包括子包

模块是一切库的基础单元
- 包由模块构成，可以理解为：包是目录，模块是py文件
- 库是通俗说法，具体指python的模块和包
- Python库的核心是模块及模块的组织方式（体现为命名空间）
```

#### 模块的命名空间

```shell
模块是命名空间
- 模块对应的.py文件，它是一个独立的命名空间
- 模块内可能包含：类、函数、语句(直接执行)、变量等元素
- 模块内还包括一些其他模块进行约束和管理的语法元素

- 模块中语句: 在import时一次性执行
- 模块内变量、类和函数：在import时采用<模块>方式可访问
- 单下划线的顶层命名元素：不会from .. import * 时导入
```

#### 包的命名空间

```python
包 package ：由一组模块构成、有层次命名空间的程序功能
- 每个包需要包含一个__init__.py 文件表达包的组织
- __init__.py 可以是空文件，即文件存在即可
- 每个包可以嵌套包含更多子包

包是一个有层次的命名空间
- 通过包的组织可以形成由英文句号(.)分隔的层次化命名空间
- __init__.py 用来构成包的定义,区别包含py文件的普通目录
- 包、子包和模块可以通过import进行导入或单独导入
```

#### 模块的名称属性

```shell
名称属性:表达模块名称的预定义变量
__name__	模块或包的名字,例: m.__name__

- 当程序以脚本方式直接执行时,__name__ 的值是 __main__
- 当程序以模块方式被直接引用时,__name__的值为模块的名称
- 作用：区别程序以何种方式执行
```

### 模块和包的构建

#### 模块的构建

```shell
模块构建原则：如何编写好一个py文件
- 功能闭包：单个py文件实现单个且完整的功能
- 抽象适度：用函数或类进行抽象，结合功能选择合适抽象
- 操作闭包：模块无顶层可执行语句，导入时无输出

- 功能闭包：功能定义要清晰，设计要合理（松耦合vs紧耦合）
- 抽象适度： 采用类或函数，尽量使用一种：多种也无妨
- 操作闭包：采用__name__、无全局可执行语句、尽量无全局变量
```

#### 常规包的构建

```shell
包由两种：常规包和命名空间包
- 常规包：Regular Packages，通过__init__.py对文件和目录组织形成包
- 命名空间包：Namespace packages，由更分散子包组成的包
- 子包的位置可以在文件系统中不连续
- 子包可以是压缩文件或网络连接或其他系统资源

常规包：Regular Packages
- 连续目录空间表达的，有层次的命名空间
- 每个目录中包含一个__init__.py文件，可以是空文件
- 当包、模块被导入时，对应目录的__init__.py文件将被执行

每个包仅被导入一次，且白导入按照层次结构进行的

__all__属性
- from .. import * 的形式需要在__init__.py文件中增加__all__属性赋值
- __all__需要被赋值为列表对象，包含当前包下所有希望被导入的模块名称
- __all__用来辅助导入模块的，不能辅助导入列表

常规包的构建流程
- 设计好层次结构(命名空间),每个目录配置一个__init__.py文件
- 完善__init__.py 文件，并酌情赋值__all__属性
- 再次理解包和模块的不同，模块是提供功能，包是提供命名空间

常规包的导入流程
- 每个包仅被导入一次，且包带入按照层次结构进行
- 直接导入包不能调用功能，需要导入到模块层次
- from .. import 直接带入具体模块，可以简化调用时命名空间表达
- __init__.py 文件中通过__all__属性支持from .. import * 的功能
```

#### 命名空间包的构建

```shell
命名空间包：表达命名空间层次结构的一种逻辑包形式
- 命名空间中各部分可以在不同的文件系统位置
- 命名空间中各子包不包含__init__.py文件(普通目录)
- Python解释器通过sys.path 变量来`隐式`维护命名空间包

sys.path ：指定搜索路径的字符串列表
- 指定import时搜索模块或包的路径列表，路径是相对或绝对路径
- sys.path是一个列表类型，可以用sys.path.append(p) 增加路径p
- 载入后，根据其中包的名称和层次自然组合成了命名空间包

__path__属性
- 记录了某个包(命名空间)的绝对路径，列表类型
- 常规包：路径单一，列表中只有一个元素
- 命名空间包:路径是多元的，列表中可能由多个元素
```

```python
# 一个简单的命名空间包
import sys
sys.path += ["project1","project2"]
import pkg1.m1
import pkg1.m3

print(pkg1.__path__)
```

### 深入理解import系统

#### import系统

```shell
import系统：扩展命名空间及功能的方法
- 构成：import 保留字、__import__()函数和importlib标准库
- 步骤：模块的查找、模块的加载
- 价值：import系统是python代码复用和命名空间管理的精髓

- import保留字：调用__import__()进行模块查找，以及模块加载
- __import__()函数：模块的查找，建立模块对象
- importlib标准库：与import系统相关的丰富api

万物皆对象：模块导入之后成为了对象
- 模块的对象形式：模块在程序中使用都是以对象形式体现
- 类似类对象，模块对象只有一个
- 模块对象生成时，模块中代码会被执行，因此会有类对象产生
```

#### 模块的查找

```shell
查找的开始
- 输入参数：模块的名字 例如：pkg.pkg1.m1
- 输入方式：import保留字，__import__()、importlib标准库
- 基本行为：按层次结构逐层查找：例如pkg->pkg1->m1

查找路径：1.sys.modules
- 第一步查找sys.modules，之前被引入模块的缓存(cache)
- sys.modules是一个字典，<模块名/对象引用>：加载路径
- 如果模块不在sys.modules中，则进入下一步

查找路径:2.查找策略
- 用户通过import钩子扩展的查找方式
- 内置模块的路径
- sys.path(列表变量)提供的加载路径，可以是zip文件或url文件

import钩子：import hook
- 扩展查找模块的方式：meta_path 方式和import路径方式
- meta_path:将查找方法增加到sys.meta_path 列表变量
- import路径：将查找方法注册到sys.path_hooks列表变量
```

#### 模块的加载

```shell
建立模块对象的过程
- 1.找到模块后，如果模块对象存在，则使用现有模块对象
- 2.创建一个新的模块对象，将其加入sys.modules 
- 3.在程序当前命名空间执行模块代码

创建对象：importlib.abc.Loader.create_module()
执行对象:importlib.abc.Loader.exec_module()

模块对象的命名空间
- 模块的命名空间与引用位有直接关系
- 如果引用在文件顶层，则使用文件顶层命名空间访问
- 如果引用在非顶层，则使用局部命名空间访问模块
```

#### import的使用方式

```python
import的三种使用方式
- import <模块名>
- from <模块名> import <类、函数名、*>
- import <模块名> as <别名>

import <模块名>
- 当前命名空间下的一个子命名空间
- 成功加载后，产生一个与<模块名>同名的<模块对象名>
- 实际上：<模块对象名>.<子命名空间内元素>方式访问

from <模块名> import <类、函数名、*>
- 将导入元素加载到当前命名空间下
- 成功加载后，产生类对象或函数对象，覆盖同名对象
- 实际上：<类对象名> 或<函数对象名>方式访问

import <模块名> as <别名>
- 当前命名空间下的一个子命名空间
- 成功加载后产生一个与<别名>同名的<模块对象名>
- 实际上：<模块别名>.<子命名空间内元素>方式访问
```

### python第三方库的发布

### 发布前的准备

```shell
Python第三方库发布
- Pypi :Python Package index ，用来登记第三方库的信息
- Github、bitbucket：存储第三方库源码及文档
- 目的：通过pip 进行安装和管理、源码和文档网络可管理

一些基本概念
- 项目 project：Pypi上一组发布和文件的统称
- 发布 release :项目的一个特定版本，每个发布有一个确定的版本号
- 文件file,即package ,一次发布包含的具体文件

更新工具
 更新 setuptools 、wheel、twine工具
 python -m pip install --user --upgrade setuptools wheel twine
```

#### 发布流程

```shell
第一步：整理目录结构
第二步：创建其他相关文件
- setup.py ：配置发布信息的文件，很重要
- README.md ：markdown格式的说明文件
- LICENSE:版权声明文件

第三步：执行打包命令
python setup.py sdist bdist_wheel
				源发布	可执行发布
第四步：执行发布命令
twine upload dist/*
```

#### 发布概念

```shell
与发布 Distribution 相关的概念
打包发布： built Distribution,对文件整理打包后进行发布
源发布：Source Distribution，发布源代码的方式，简称sdist
可执行发布：Binary Distribution，发布编译后可执行代码方式

打包发布：一次发布一个打包文件，比如：.tar.gz 或wheel文件
源发布：对于纯python编写的库，源发布有最佳的适用性
可执行发布：对于各类多语言的扩展库，节省了本机编译需求，适用性较好

与打包格式相关的概念
- Egg：一种打包格式，已经被wheel替换
- Wheel：一种打包合适，python主流打包方式，PEP427
- Egg和Wheel都是打包格式，可以包括源代码或可执行代码
```

### C语言概述

#### c语言概述

```shell
C语言：与操作系统直接交互的便车会给你语言
- 1973年，由Dennis Ritchie设计，用于重写Unix操作系统
- 通用语言、过程式编程语言，重点关注程序执行效率
- C语言也提供函数API，但严格受控

c89:ANSI标准化的C语言版本，也被称为标准c或ANSI 、ISO版本
c99：1999年改进版本，inline、变长数组等新语法，需要额外声明
c11:2011年版本，匿名结构，Unicode支持，边界检查函数等
c18:2018年6月版本，无新语法增加

python解释器采用c语言编写：被称为Cpython
Python从未试图替换C语言，而是通过扩展与C语言并存，各展所长
C和Python都将是不可超越的经典

C语言的精髓
C语言精髓在于灵活语法下内存有效管理
无论何种语法形态，最终体现为数据在内存中栈和堆的存储和操作
C语言可以直接精细到操作每个比特和字节，充分发挥计算机效率
```

#### c语言语法

```c
C语言的注释
- 多行注释： /*......*/
- 单行注释： //
- 注释完全被编译器忽略，但很多工具可以提取注释形成文档

C语言的所属关系
- 大括号表达所属关系：{....}
- 函数，分支，循环等定义中使用
- 表达式用分号；隔离，表示结束

C语言的声明Declaration
- 变量及函数需要声明再使用，声明要指定类型
- 声明需要使用保留或内置数据类型（char int）等
- 相关保留字：struct、union、enum

C语言的程序控制结构
- 分支 if,if-else,switch-case,default,goto
- 循环：do-while,while,for,break,continue
- 分支和循环都可以嵌套定义和使用

C语言的字符集
- 字母和数字：a-z A-Z 0-9
- 特殊字符 ! " # % & ' () * +、- . /:;< = > ? [\]^_ {|} ~
- 隐式字符：空格、制表符TAB、换行等


c语言的操作符
- 数学操作符： +、-、*、/、%
- 赋值操作符： =
- 增强赋值操作符号：+=、-=、*= /= %= &= |= ^= <<= >>=
- 位逻辑操作符：～，&，|，^
- 位移位操作符：<<,>>
- 布尔运算操作符：！，&& , ||
- 条件评估操作符：?:
- 比较操作符：<,>,<=,>=,==,!=
- 自操作符：++,--
- 成员选择操作符：. , ->
- 指针引用操作符：&，*,[]
- 分组操作符：()

```

| auto     | do       | goto       | `signed` | `unsigned` |
| -------- | -------- | ---------- | -------- | ---------- |
| break    | `double` | if         | sizeof   | void       |
| case     | else     | `int`      | static   | `volatile` |
| char     | enum     | `long`     | struct   | while      |
| const    | extern   | `register` | switch   | inline     |
| continue | `float`  | return     | typedef  | restrict   |
| default  | for      | `short`    | union    |            |

#### c开发环境配置

#### c语言实例

#### 编译和解释

```shell
C语言是一种约定数据类型的语言
- 类型声明无处不在：变量，函数
- 数据类型的本质：计算机内存空间的外在表现
- 类型声明体现了编译语言的特点，即：编译阶段能够评估内存使用

编译和解释的一般区别
- 编译语言：C语言，编译器一次性生成目标代码，优化更充分
	- 需要编程语言能够确定的元素尽量确定，如数据类型，引用关系
- 脚本语言：python语言，执行程序时需要源代码，维护更灵活
	- 不需要在编程阶段确定更多信息，如数据类型、引用关系等，靠执行先后决定

python语言 VS C语言
- 脚本语言 VS 编译语言（静态语言）
- 根据执行情况确定语句含义 vs 编译阶段需要确定语句含义
- 重在程序员的隐形约定 VS 重在程序中的显式声明
```

### python与C的交互方法

#### python与c的交互概念

```shell
Python与C、C++交互的三种方式
- Python的扩展：在python程序中调用c、C++编写的库
- Python的嵌入：在c、C++程序中调用python程序
- Python调用：python和c间以程序级别的互相调用

python与C、C++交互的价值
- 整合python高产与C、C++高效的优势
- 利用C或Python已有功能服务彼此的程序
- python作为粘性脚本整合或被整合到个类独立程序

python扩展：在python程序中调用c、C++编写的库
- 目的：提升关键代码性能，引入C语言成熟功能库
- 方式：Cython、SWIG、ctypes，CFFI
- 形式：python为主程序，c通过.dll/.so形式使用

Python的嵌入：在c、C++程序中调用python程序
- 目的：利用python高产，引入python成熟的功能库
- 方式python、c API
- 形式c、C++ 为主程序，python通过源文件形式使用

Python调用：python和c间以程序级别的互相调用
- 目的：模块功能互用，以功能使用为目标
- 方式：子进程或线程方式，即subprocess
- 形式c、c++和python都是独立程序
```

#### python的扩展方法

```shell
Cython：实现python扩展的一种语言，第三方库
- 思路：通过一种简单的语言来实现python和c的接口
- 方式：采用Pyrex语法形式
- 结果：采用c数据类型的python编程，实现混合编程

SWIG：一个将c、c++与脚本语言相整合的编译器，独立工具
- 思路：通过一个编译器来实现python与c的接口
- 方式：纯c、C++编程，通过编写接口变成python模块
- 结果：独立c和python编程，重点在于编写接口（描述）

ctypes：调用dll或共享库的python功能函数库，标准库API
- 思路：通过一个python标准库实现python扩展
- 方式：c语言功能编为.dll或.so 库，加载库及调用函数，API
- 结果：c语言独立编程，python使用库调用接口函数

CFFI：在python中直接使用c函数方式，第三方库
- 思路：类似ctypes，使用api扩展c程序，也可以直接混合编程
- 方式：关注c函数的访问接口，而不是库函数，构建API
- 结果：c语言独立编程，python用CFFI扩展，最小学习代价
```

#### python的嵌入方法

```shell
python、c API：python嵌入的主要接口
- 嵌入python语句：嵌入一个或多个python语句
- 嵌入python脚本：嵌入一个或多个python文件
- python、c API需要加载python解释器及加载python语句和脚本

- python/c API是一组能够在c语言下执行类定义和函数
- 头文件：Python.h
- 函数：加载python解释器、嵌入Python语句及脚本、数据类型转换等
```

加载Python解释器

| 函数                                          | 描述                                                       |
| --------------------------------------------- | ---------------------------------------------------------- |
| Py_Initialize()                               | 初始化python解释器，加载builtins，`__main__`、sys等        |
| Py_Finalize()                                 | 终结化python解释器，释放解释器占用的内存                   |
| PyRun_simpleString(const char * cmd)          | 在`__main__`模块中执行一条语句，如果`__main__`不存在则创建 |
| PyRun_SimpleFile(FILE *fp,const char * fname) | 在c中调用Python文件                                        |

#### python的调用方法

```shell
在python中调用c语言程序
- 使用python的subprocess模块

python与c间以程序级别互相调用
- Python调用c：subprocess模块
- C调用Python：system()函数
```

### python扩展的CFFI方法

CFFI的概述

```shell
CFFI： C Foreign Function Interface for Python
思路：类似ctypes，使用API扩展c程序，也可以直接混合编程
方式：关注c函数的访问接口，而不是库函数，构建API
结果：c语言独立编程，Python用CFFI扩展，最小学习代价

- 库扩展：对已经编译好的c语言.dll 或.so 库调用并使用
- 标准库：c语言标准库的调用及使用
- 数据类型：c语言与python数据类型的转换

- 安装： pip install cffi

```

#### CFFI的功能接口

| 函数                     | 描述                                                     |
| ------------------------ | -------------------------------------------------------- |
| ffi.NULL                 | 相当于常量值NULL                                         |
| ffi.new(cdecl)           | 数组或指针生成，new('x *') 或new('x[n]')                 |
| ffi.cast(ctype,value)    | c数据类型声明，ctype是类型名，value是变量，cast('int',x) |
| ffi.string(cdata)        | 从cdata类型返回一个python字符串                          |
| ffi.unpack(cdata,lenght) | 从cdata数组中获取特定长度，返回一个python字符串或列表    |
| ffi.typeof(ctype)        | 返回ctype的长度                                          |
| ffi.sizeof(object)       | 返回object对象长度                                       |
| ffi.alignof(ctype)       | 返回ctype或对象的长度                                    |
| ffi.dlopen(libpath)      | 打开动态链接库并建立一个链接                             |
| ffi.diclose(lib)         | 关闭动态链接并释放句柄                                   |
| ffi.cdef(str)            | str指明python中需要使用的c类型，函数等声明               |
| ffi.memmove(dst,src,n)   | 从src向dst拷贝n直接内容，注意src和dst都是python变量      |
|                          |                                                          |
|                          |                                                          |



### 精进的python语法

上下文管理器，异步，协程

迭代器，生成器

装饰器和语法糖

### 精进的python语言

全部保留字

全部特殊字符

全部内置函数

### 精进的python计算生态

数据分析到人工智能

web解析到网络空间

人机交互到艺术设计

















































