## 什么是进程

- 进程的概念
  - 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础
- 操作系统引入进程的概念的原因
  - 从理论角度看，是对正在运行的程序过程的抽象； 从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。
- 进程的特征
  - **动态性：**进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。
  - **并发性：**任何进程都可以同其他进程一起并发执行
  - **独立性：**进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；
  - **异步性：**由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进
  - **结构特征：**进程由程序、数据和进程控制块三部分组成。
  - 多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。
- 进程与程序中的区别
  - 程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。 程序是永久的，进程是暂时的。
- 操作系统种类:
  - 多道
  - 分时
  - 实时
- 操作系统的作用:
  - 帮助你调度硬件资源,帮助你调度管理软件

## 进程的调度

- **先来先服务调度算法**
  - 先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。
- **短作业优先调度算法**
  - 短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。
- **时间片轮转法**
  - 时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例
  - 一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。
  - 另一种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。
  - 第三种情况就是新创建进程进入就绪队列。
- **多级反馈队列**
  - (1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。
  - (2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。
  - (3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。

## 进程的并发与并行

- 并行:有多个cpu在同时执行任务
- 并发:只有一个cpu,交替执行多个任务

## 同步异步阻塞和非阻塞

- 同步:就是顺序执行
- 异步:可以同时执行
- 阻塞:停住
- 非阻塞:不停

## 进程的创建与结束

- 进程的创建
  - 1.系统的初始化
  - 2.一个进程在运行中开启了子进程
  - 3.用户的交互请求,而创建一个新进程
  - 4.一个批处理作业的初始化
- 进程的结束
  - 1.正常退出(资源,如点击程序右上角的×号)
  - 2.出错退出
  - 3.严重 错误
  - 4.被其他进程杀死

## 在python程序中的进程操作

- `multiprocess`模块用来处理进程问题的

## 创建进程部分

- 使用模块 **from multiprocessing import Process**(引入模块)
- **p = Process(target=(函数名或类名),args = (**参数,需要是元祖类型(函数专用)))
- **p.start()启动进程**
- **p.run()**:进程启动时运行的方法,正是它去调用target指定的函数,我们自己定义的类中一定要实现该方法
- **p.terminate()**:强制终止进程p,不会进行任何清理操作
- **p . is_alive():**如果p仍然运行,返回一个True
- **p.join([timeout]):主线程等待p终止(这时:主线程处于等待状态,而p处于运行状态),timeout是可选超时时间,需要强调的是:p.join只能join住start开启的进程,而不能join住run开启的进程**
- 在Windows操作系统下,使用这个模块需要在 if __name__ == __main__:下使用,这是当做模块import过来的
- 在mac或linux下则不用,因为这是复制
- 进程之间的数据是隔离的
  - 进程和进程之间是不能自由的交换内存数据的
  - 全局的变量在子进程中修改 其他进程是感知不到的

## 守护进程

- 特点 生命周期只和主进程的代码有关系,和其他子程序没有关系
- 用处 `报活`
- 用法:p.deamon = True(守护主程序):当主程序的代码执行完毕,它就会被强制结束
- 进程的同步控制:进程之间有一些简单的信号传递,但是用户不能感知,且用户不能传递自己想传递的内容

## 锁Lock

- **lock = Lock()**创造一把锁
- **lock.scquire()**获取这把锁的钥匙
- **lock.release()** 归还这把锁的钥匙
- 只要钥匙被一个用户拿了,下一个用户想拿,必须等上一个用户把钥匙归还了才能走下去,要不就会一直堵下去

## 信号量:Semaphore

- 信号量的**本质**就是:**锁+计数器**
- sem = Semaphore(钥匙的个数)
- sem.acquire()拿钥匙
- sem.release()归还钥匙

## 事件Event

- wait()方法 等待里面可以加timeout = 时间,只要这个时间到了,就不会管是不是False了
- e.is.set() 查看标志(默认False)
- e.clear() 把标志设置为false
- e.set():把标志设置为True

## IPC通信:进程间通信

- **with as机制**
  - 必须要有两个方法`__enter__`和`__exit__`,才能运行这个类
  - def `__enter__`(**self):
  - return self
  - def `__exit`__(self,exc_type,exc_val,exc_tb):
  - return self

## 队列

- 模块 Queue
  - 使用方法
    - q = Queue()
    - q.get()得到数据,如果没有就会一直等下去
    - q.get_nowait();得到数据,不会等待,如果没有就报错
    - q.put():输入值,如果队列满了话,会等待
    - q.put_nowait():一直输入,如果满的话就报错,不会等待
    - q.qsize(n):n是指定队列的长度
    - q.empty(): 判断队列是否为空
    - q.full():判断队列是否满了
- 模块 JoinableQueue
  - 使用方法:
    - q = Queue()
    - q.get()得到数据,如果没有就会一直等下去
    - q.get_nowait();得到数据,不会等待,如果没有就报错
    - q.put():输入值,如果队列满了话,会等待
    - q.put_nowait():一直输入,如果满的话就报错,不会等待
    - q.qsize(n):n是指定队列的长度
    - q.empty(): 判断队列是否为空
    - q.full():判断队列是否满了
    - q.join:判断队列全部接收完毕之后,才结束
    - q.task_done():每接收一个,就会给发送者一个信号,说接收到了
- 生产者和消费者模型
  - 解决创造(生产)数据和处理(消费)数据的效率不平衡的问题
  - 把创造数据和处理数据放在不同的过程中
  - 根据他们的效率调整进程的个数
  - 生产数据快 消费数据慢 内存空间的浪费
  - 生产数据慢 消费数据快 效率低下
- 内存控制----队列的长度限制
- 让生产者自动停下来

## 管道

- 基本知识
  - 队列就是基于管道事项的
  - 队列 数据安全
  - 管道 数据不安全
  - 队列=管道+锁
- 模块 Pipe
  - left,right = Pipe()
  - 使用的时候需要关闭端口
  - left.send():传输内容
  - right.recv():接收内容
  - left.close():关闭端口
- EOR异常触发:
  - 在这个过程中,如果不再用这个短点了,应该close
  - 这在recv的时候,如果其他端点都被关闭了,就能够知道不会再有新消息传过来
  - 此时就不会在这里阻塞等待,而是抛出一个EOFError错误
  - *.close()并不是关闭整个管道,而是修改了操作系统对管道端点的引用计数处理
- 如何介绍什么是管道:
  - IPC通信的一种机制,队列就是基于管道来完成通信的,但是管道是原生的通信方式
  - 在进程之间会产生数据不安全的情况,需要自己手动加锁处理
  - 管道在数据传输过程中,还涉及一个端口管理,这个需要我们在代码中处理,让代码变得更加完善

## 数据共享

- 模块 Manager()
- m = Manager():实例化一个对象
- dic = m.dict({'count':100})
- dic里面的值不管哪一个子进程都可以对其查看和修改
- 进程池
  - 基本信息:
    - 如果必须使用多进程
      - 且是高计算型,没有IO型的程序
      - 希望并行,最充分的使用cpu
  - 模块 Pool
    - p = Pool(5):实例化对象,5是进程的个数
    - p.apply_async(,func,args=(i,)):所有开启的进程都在这个数据池里
    - p.close()
    - p.join()阻塞住

## 进程池

### 使用方法

- 模块是Pool
- p = Pool()默认是你自己计算机cup的个数
- p.apply(func = wahaha):这个是同步的
- ret = p.apply_async(func = wahaha):这是异步的
- ret是一个对象,他可以通过get来取到每个进程的返回值
- p.close():关闭进程池,让任务不能再继续提交了
- p.join():等待所有子进程中的代码全部执行完毕

### 异步的apply_async

- 1.如果是异步 的提交任务,,那么任务提交之后进程池和主进程也异步了,主进程不会自动等待进程池中的任务执行完毕
- 2.如果需要主进程等待,需要p.join(),但是join需要依赖close来关闭进程池
- 3.如果这个函数有返回值
  - 也可以通过ret.get()来获取返回值
  - 但是如果一边提交一边获取返回值会让程序变成同步的
  - 所有要想保留异步的效果,让返回对象保存在列表里,所有任务提交完毕之后再来取结果
  - 这种方式也可以去掉join,来完成主进程的阻塞来等待进程池中的任务执行完毕

### 回调函数

- 回调函数在 主进程中执行
- 在发起任务的时候指定callback参数
- 在每个进程执行完apply_async任务后,返回值直接作为参数传递给callback所指定的函数,执行callback所指定函数中的代码

## 进程总结

- 进程三状态:
  - 1.就绪
  - 2.运行
  - 3.阻塞
- 进程是计算机最小的资源分配单位
- 进程的创建Process
- 进程间的异步 本身子进程和主进程之间都是异步的
- 进程之间的同步控制 Lock(锁),Semaphore(信号量),Event(事件)
- 进程之间的数据隔离 本身进程与进程之间都是数据隔离的
- 进程之间的通信 IPC 管道和队列
- 数据共享 Manager
- 进程池 可以获取返回值
  - 同步调用,基本不用
  - 异步调用 重要的
    - apply_async
    - get 获取结果
    - join
  - 回调函数 Pool 回调函数在主进程中执行
    - apply_async(func = 要执行的函数,callback = 回调函数)

## multiprocessing库的基本方法

##### 进程之间的同步

- **1.Process:模块**

  - 基本介绍:

    - 参数介绍:
      - Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）
      - **1. group参数未使用，值始终为None**
      - **2.target表示调用对象，即子进程要执行的任务**
      - **3 args表示调用对象的位置参数元组，args=(1,):必须是一个元祖**
      - **4.kwargs表示调用对象的字典,kwargs={'name':'egon','age':18}**
      - **5 name为子进程的名称**
    - 方法介绍
      - **1.p.start()：启动进程，并调用该子进程中的p.run()**
      - **2. p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法**
      - **3.p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁**
      - **4. p. is_alive():如果p仍然运行，返回True**
      - **p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程**
    - 属性介绍:
      - **1.p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置**
      - **2. p .name:进程的名称**
      - **3.p.pid：进程的pid**
      - **4.p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)**
      - **5.p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）**
    - 在windows中使用Process中使用process模块的注意事项
      - 在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用**if __name__ ==‘__main__’ 判断保护起来，import 的时候 ，就不会递归运行了。**

  - 代码实例

    ![img](https://mubu.com/document_image/18c7ced4-e48f-4099-ae96-fc63fde726dd-1067905.jpg)

- **2.锁(lock):**

  - 代码:

    ![img](https://mubu.com/document_image/d63cdb67-45df-4728-8588-da10a11c1d8d-1067905.jpg)

    ![img](https://mubu.com/document_image/c254ba2b-8010-43de-9ec9-4d55ac774088-1067905.jpg)结果

    ![img](https://mubu.com/document_image/78d5d15a-522d-4e03-92c4-f4e1eb1c0b78-1067905.jpg)

- **3.信号量(Semaphore):**

  - 实例代码:

    ![img](https://mubu.com/document_image/63562b00-950e-4cfa-82f1-aecd0d63d637-1067905.jpg)

  - 结果:

    ![img](https://mubu.com/document_image/1ab86ddd-6215-4b53-b4e6-a0f4291f3761-1067905.jpg)

- **4.事件(Event**)

  - **代码:**

    ![img](https://mubu.com/document_image/fc47bd6a-4600-4f61-a195-dfea78a5fc0f-1067905.jpg)

    ![img](https://mubu.com/document_image/62eef6b3-9997-4518-85a6-e0340ea90fb6-1067905.jpg)

    ![img](https://mubu.com/document_image/b29f7861-b0c3-4ceb-8d9c-d64742b81d84-1067905.jpg)

  - 结果:

    ![img](https://mubu.com/document_image/fca28e75-448a-449b-b46e-47c6094e1526-1067905.jpg)

- **进程之间的通信**

  - **队列(Queue)**

    - 实例代码:

      ![img](https://mubu.com/document_image/02cc1ca7-1a89-463b-9728-1e9411c12b5e-1067905.jpg)

      ![img](https://mubu.com/document_image/51c1209a-037c-43ec-9a17-65da9ed4a9da-1067905.jpg)

      ![img](https://mubu.com/document_image/a9d56b32-9a3b-41c1-b203-998668fcb0db-1067905.jpg)

    - 输出结果:

      ![img](https://mubu.com/document_image/f28966ac-4b9d-4e14-9be9-fd76a8b427e4-1067905.jpg)

  - **管道(Pipe)**

    - 代码:

      ![img](https://mubu.com/document_image/531d4755-856e-4e1d-b9f5-63d4259a3d7f-1067905.jpg)

      ![img](https://mubu.com/document_image/1a6776e5-9949-44be-ad40-c3044a5a5aa9-1067905.jpg)

- **进程池(Pool)**

  - 代码:

    ![img](https://mubu.com/document_image/c327caec-a2e1-4bc4-964f-7bbfd86c68d7-1067905.jpg)

  - 结果:

    ![img](https://mubu.com/document_image/7d05055a-1ce9-4d03-9e63-18589327f227-1067905.jpg)